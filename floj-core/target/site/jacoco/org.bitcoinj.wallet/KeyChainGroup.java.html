<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>KeyChainGroup.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">bitcoinj</a> &gt; <a href="index.source.html" class="el_package">org.bitcoinj.wallet</a> &gt; <span class="el_source">KeyChainGroup.java</span></div><h1>KeyChainGroup.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2014 Mike Hearn
 * Copyright 2014 Andreas Schildbach
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.bitcoinj.wallet;

import com.google.common.collect.*;
import com.google.protobuf.*;
import org.bitcoinj.core.*;
import org.bitcoinj.crypto.*;
import org.bitcoinj.script.*;
import org.bitcoinj.utils.*;
import org.bitcoinj.wallet.listeners.KeyChainEventListener;
import org.slf4j.*;
import org.spongycastle.crypto.params.*;

import javax.annotation.*;
import java.security.*;
import java.util.*;
import java.util.concurrent.*;

import static com.google.common.base.Preconditions.*;

/**
 * &lt;p&gt;A KeyChainGroup is used by the {@link org.bitcoinj.wallet.Wallet} and
 * manages: a {@link BasicKeyChain} object (which will normally be empty), and zero or more
 * {@link DeterministicKeyChain}s. A deterministic key chain will be created lazily/on demand
 * when a fresh or current key is requested, possibly being initialized from the private key bytes of the earliest non
 * rotating key in the basic key chain if one is available, or from a fresh random seed if not.&lt;/p&gt;
 *
 * &lt;p&gt;If a key rotation time is set, it may be necessary to add a new DeterministicKeyChain with a fresh seed
 * and also preserve the old one, so funds can be swept from the rotating keys. In this case, there may be
 * more than one deterministic chain. The latest chain is called the active chain and is where new keys are served
 * from.&lt;/p&gt;
 *
 * &lt;p&gt;The wallet delegates most key management tasks to this class. It is &lt;b&gt;not&lt;/b&gt; thread safe and requires external
 * locking, i.e. by the wallet lock. The group then in turn delegates most operations to the key chain objects,
 * combining their responses together when necessary.&lt;/p&gt;
 *
 * &lt;p&gt;Deterministic key chains have a concept of a lookahead size and threshold. Please see the discussion in the
 * class docs for {@link DeterministicKeyChain} for more information on this topic.&lt;/p&gt;
 */
public class KeyChainGroup implements KeyBag {

    static {
        // Init proper random number generator, as some old Android installations have bugs that make it unsecure.
<span class="pc bpc" id="L60" title="1 of 2 branches missed.">        if (Utils.isAndroidRuntime())</span>
<span class="nc" id="L61">            new LinuxSecureRandom();</span>
    }

<span class="fc" id="L64">    private static final Logger log = LoggerFactory.getLogger(KeyChainGroup.class);</span>

    private BasicKeyChain basic;
    private NetworkParameters params;
    protected final LinkedList&lt;DeterministicKeyChain&gt; chains;
    // currentKeys is used for normal, non-multisig/married wallets. currentAddresses is used when we're handing out
    // P2SH addresses. They're mutually exclusive.
    private final EnumMap&lt;KeyChain.KeyPurpose, DeterministicKey&gt; currentKeys;
    private final EnumMap&lt;KeyChain.KeyPurpose, Address&gt; currentAddresses;
    @Nullable private KeyCrypter keyCrypter;
<span class="fc" id="L74">    private int lookaheadSize = -1;</span>
<span class="fc" id="L75">    private int lookaheadThreshold = -1;</span>

    /** Creates a keychain group with no basic chain, and a single, lazily created HD chain. */
    public KeyChainGroup(NetworkParameters params) {
<span class="fc" id="L79">        this(params, null, new ArrayList&lt;DeterministicKeyChain&gt;(1), null, null);</span>
<span class="fc" id="L80">    }</span>

    /** Creates a keychain group with no basic chain, and an HD chain initialized from the given seed. */
    public KeyChainGroup(NetworkParameters params, DeterministicSeed seed) {
<span class="fc" id="L84">        this(params, null, ImmutableList.of(new DeterministicKeyChain(seed)), null, null);</span>
<span class="fc" id="L85">    }</span>

    /**
     * Creates a keychain group with no basic chain, and an HD chain that is watching the given watching key.
     * This HAS to be an account key as returned by {@link DeterministicKeyChain#getWatchingKey()}.
     */
    public KeyChainGroup(NetworkParameters params, DeterministicKey watchKey) {
<span class="fc" id="L92">        this(params, null, ImmutableList.of(DeterministicKeyChain.watch(watchKey)), null, null);</span>
<span class="fc" id="L93">    }</span>

    // Used for deserialization.
    private KeyChainGroup(NetworkParameters params, @Nullable BasicKeyChain basicKeyChain, List&lt;DeterministicKeyChain&gt; chains,
<span class="fc" id="L97">                          @Nullable EnumMap&lt;KeyChain.KeyPurpose, DeterministicKey&gt; currentKeys, @Nullable KeyCrypter crypter) {</span>
<span class="fc" id="L98">        this.params = params;</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">        this.basic = basicKeyChain == null ? new BasicKeyChain() : basicKeyChain;</span>
<span class="fc" id="L100">        this.chains = new LinkedList&lt;DeterministicKeyChain&gt;(checkNotNull(chains));</span>
<span class="fc" id="L101">        this.keyCrypter = crypter;</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">        this.currentKeys = currentKeys == null</span>
                ? new EnumMap&lt;KeyChain.KeyPurpose, DeterministicKey&gt;(KeyChain.KeyPurpose.class)
                : currentKeys;
<span class="fc" id="L105">        this.currentAddresses = new EnumMap&lt;KeyChain.KeyPurpose, Address&gt;(KeyChain.KeyPurpose.class);</span>
<span class="fc" id="L106">        maybeLookaheadScripts();</span>

<span class="fc bfc" id="L108" title="All 2 branches covered.">        if (isMarried()) {</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">            for (Map.Entry&lt;KeyChain.KeyPurpose, DeterministicKey&gt; entry : this.currentKeys.entrySet()) {</span>
<span class="fc" id="L110">                Address address = makeP2SHOutputScript(entry.getValue(), getActiveKeyChain()).getToAddress(params);</span>
<span class="fc" id="L111">                currentAddresses.put(entry.getKey(), address);</span>
<span class="fc" id="L112">            }</span>
        }
<span class="fc" id="L114">    }</span>

    // This keeps married redeem data in sync with the number of keys issued
    private void maybeLookaheadScripts() {
<span class="fc bfc" id="L118" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains) {</span>
<span class="fc" id="L119">            chain.maybeLookAheadScripts();</span>
<span class="fc" id="L120">        }</span>
<span class="fc" id="L121">    }</span>

    /** Adds a new HD chain to the chains list, and make it the default chain (from which keys are issued). */
    public void createAndActivateNewHDChain() {
        // We can't do auto upgrade here because we don't know the rotation time, if any.
<span class="fc" id="L126">        final DeterministicKeyChain chain = new DeterministicKeyChain(new SecureRandom());</span>
<span class="fc" id="L127">        addAndActivateHDChain(chain);</span>
<span class="fc" id="L128">    }</span>

    /**
     * Adds an HD chain to the chains list, and make it the default chain (from which keys are issued).
     * Useful for adding a complex pre-configured keychain, such as a married wallet.
     */
    public void addAndActivateHDChain(DeterministicKeyChain chain) {
<span class="fc" id="L135">        log.info(&quot;Creating and activating a new HD chain: {}&quot;, chain);</span>
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">        for (ListenerRegistration&lt;KeyChainEventListener&gt; registration : basic.getListeners())</span>
<span class="nc" id="L137">            chain.addEventListener(registration.listener, registration.executor);</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">        if (lookaheadSize &gt;= 0)</span>
<span class="fc" id="L139">            chain.setLookaheadSize(lookaheadSize);</span>
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">        if (lookaheadThreshold &gt;= 0)</span>
<span class="nc" id="L141">            chain.setLookaheadThreshold(lookaheadThreshold);</span>
<span class="fc" id="L142">        chains.add(chain);</span>
<span class="fc" id="L143">    }</span>

    /**
     * Returns a key that hasn't been seen in a transaction yet, and which is suitable for displaying in a wallet
     * user interface as &quot;a convenient key to receive funds on&quot; when the purpose parameter is
     * {@link KeyChain.KeyPurpose#RECEIVE_FUNDS}. The returned key is stable until
     * it's actually seen in a pending or confirmed transaction, at which point this method will start returning
     * a different key (for each purpose independently).
     * &lt;p&gt;This method is not supposed to be used for married keychains and will throw UnsupportedOperationException if
     * the active chain is married.
     * For married keychains use {@link #currentAddress(KeyChain.KeyPurpose)}
     * to get a proper P2SH address&lt;/p&gt;
     */
    public DeterministicKey currentKey(KeyChain.KeyPurpose purpose) {
<span class="fc" id="L157">        DeterministicKeyChain chain = getActiveKeyChain();</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">        if (chain.isMarried()) {</span>
<span class="fc" id="L159">            throw new UnsupportedOperationException(&quot;Key is not suitable to receive coins for married keychains.&quot; +</span>
                                                    &quot; Use freshAddress to get P2SH address instead&quot;);
        }
<span class="fc" id="L162">        DeterministicKey current = currentKeys.get(purpose);</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">        if (current == null) {</span>
<span class="fc" id="L164">            current = freshKey(purpose);</span>
<span class="fc" id="L165">            currentKeys.put(purpose, current);</span>
        }
<span class="fc" id="L167">        return current;</span>
    }

    /**
     * Returns address for a {@link #currentKey(KeyChain.KeyPurpose)}
     */
    public Address currentAddress(KeyChain.KeyPurpose purpose) {
<span class="fc" id="L174">        DeterministicKeyChain chain = getActiveKeyChain();</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">        if (chain.isMarried()) {</span>
<span class="fc" id="L176">            Address current = currentAddresses.get(purpose);</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">            if (current == null) {</span>
<span class="fc" id="L178">                current = freshAddress(purpose);</span>
<span class="fc" id="L179">                currentAddresses.put(purpose, current);</span>
            }
<span class="fc" id="L181">            return current;</span>
        } else {
<span class="fc" id="L183">            return currentKey(purpose).toAddress(params);</span>
        }
    }

    /**
     * Returns a key that has not been returned by this method before (fresh). You can think of this as being
     * a newly created key, although the notion of &quot;create&quot; is not really valid for a
     * {@link DeterministicKeyChain}. When the parameter is
     * {@link KeyChain.KeyPurpose#RECEIVE_FUNDS} the returned key is suitable for being put
     * into a receive coins wizard type UI. You should use this when the user is definitely going to hand this key out
     * to someone who wishes to send money.
     * &lt;p&gt;This method is not supposed to be used for married keychains and will throw UnsupportedOperationException if
     * the active chain is married.
     * For married keychains use {@link #freshAddress(KeyChain.KeyPurpose)}
     * to get a proper P2SH address&lt;/p&gt;
     */
    public DeterministicKey freshKey(KeyChain.KeyPurpose purpose) {
<span class="fc" id="L200">        return freshKeys(purpose, 1).get(0);</span>
    }

    /**
     * Returns a key/s that have not been returned by this method before (fresh). You can think of this as being
     * newly created key/s, although the notion of &quot;create&quot; is not really valid for a
     * {@link DeterministicKeyChain}. When the parameter is
     * {@link KeyChain.KeyPurpose#RECEIVE_FUNDS} the returned key is suitable for being put
     * into a receive coins wizard type UI. You should use this when the user is definitely going to hand this key out
     * to someone who wishes to send money.
     * &lt;p&gt;This method is not supposed to be used for married keychains and will throw UnsupportedOperationException if
     * the active chain is married.
     * For married keychains use {@link #freshAddress(KeyChain.KeyPurpose)}
     * to get a proper P2SH address&lt;/p&gt;
     */
    public List&lt;DeterministicKey&gt; freshKeys(KeyChain.KeyPurpose purpose, int numberOfKeys) {
<span class="fc" id="L216">        DeterministicKeyChain chain = getActiveKeyChain();</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">        if (chain.isMarried()) {</span>
<span class="fc" id="L218">            throw new UnsupportedOperationException(&quot;Key is not suitable to receive coins for married keychains.&quot; +</span>
                    &quot; Use freshAddress to get P2SH address instead&quot;);
        }
<span class="fc" id="L221">        return chain.getKeys(purpose, numberOfKeys);   // Always returns the next key along the key chain.</span>
    }

    /**
     * Returns address for a {@link #freshKey(KeyChain.KeyPurpose)}
     */
    public Address freshAddress(KeyChain.KeyPurpose purpose) {
<span class="fc" id="L228">        DeterministicKeyChain chain = getActiveKeyChain();</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">        if (chain.isMarried()) {</span>
<span class="fc" id="L230">            Script outputScript = chain.freshOutputScript(purpose);</span>
<span class="fc" id="L231">            checkState(outputScript.isPayToScriptHash()); // Only handle P2SH for now</span>
<span class="fc" id="L232">            Address freshAddress = Address.fromP2SHScript(params, outputScript);</span>
<span class="fc" id="L233">            maybeLookaheadScripts();</span>
<span class="fc" id="L234">            currentAddresses.put(purpose, freshAddress);</span>
<span class="fc" id="L235">            return freshAddress;</span>
        } else {
<span class="fc" id="L237">            return freshKey(purpose).toAddress(params);</span>
        }
    }

    /** Returns the key chain that's used for generation of fresh/current keys. This is always the newest HD chain. */
    public final DeterministicKeyChain getActiveKeyChain() {
<span class="fc bfc" id="L243" title="All 2 branches covered.">        if (chains.isEmpty()) {</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">            if (basic.numKeys() &gt; 0) {</span>
<span class="fc" id="L245">                log.warn(&quot;No HD chain present but random keys are: you probably deserialized an old wallet.&quot;);</span>
                // If called from the wallet (most likely) it'll try to upgrade us, as it knows the rotation time
                // but not the password.
<span class="fc" id="L248">                throw new DeterministicUpgradeRequiredException();</span>
            }
            // Otherwise we have no HD chains and no random keys: we are a new born! So a random seed is fine.
<span class="fc" id="L251">            createAndActivateNewHDChain();</span>
        }
<span class="fc" id="L253">        return chains.get(chains.size() - 1);</span>
    }

    /**
     * Sets the lookahead buffer size for ALL deterministic key chains as well as for following key chains if any exist,
     * see {@link DeterministicKeyChain#setLookaheadSize(int)}
     * for more information.
     */
    public void setLookaheadSize(int lookaheadSize) {
<span class="fc" id="L262">        this.lookaheadSize = lookaheadSize;</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains) {</span>
<span class="fc" id="L264">            chain.setLookaheadSize(lookaheadSize);</span>
<span class="fc" id="L265">        }</span>
<span class="fc" id="L266">    }</span>

    /**
     * Gets the current lookahead size being used for ALL deterministic key chains. See
     * {@link DeterministicKeyChain#setLookaheadSize(int)}
     * for more information.
     */
    public int getLookaheadSize() {
<span class="fc bfc" id="L274" title="All 2 branches covered.">        if (lookaheadSize == -1)</span>
<span class="fc" id="L275">            return getActiveKeyChain().getLookaheadSize();</span>
        else
<span class="fc" id="L277">            return lookaheadSize;</span>
    }

    /**
     * Sets the lookahead buffer threshold for ALL deterministic key chains, see
     * {@link DeterministicKeyChain#setLookaheadThreshold(int)}
     * for more information.
     */
    public void setLookaheadThreshold(int num) {
<span class="fc bfc" id="L286" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains) {</span>
<span class="fc" id="L287">            chain.setLookaheadThreshold(num);</span>
<span class="fc" id="L288">        }</span>
<span class="fc" id="L289">    }</span>

    /**
     * Gets the current lookahead threshold being used for ALL deterministic key chains. See
     * {@link DeterministicKeyChain#setLookaheadThreshold(int)}
     * for more information.
     */
    public int getLookaheadThreshold() {
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">        if (lookaheadThreshold == -1)</span>
<span class="fc" id="L298">            return getActiveKeyChain().getLookaheadThreshold();</span>
        else
<span class="nc" id="L300">            return lookaheadThreshold;</span>
    }

    /** Imports the given keys into the basic chain, creating it if necessary. */
    public int importKeys(List&lt;ECKey&gt; keys) {
<span class="fc" id="L305">        return basic.importKeys(keys);</span>
    }

    /** Imports the given keys into the basic chain, creating it if necessary. */
    public int importKeys(ECKey... keys) {
<span class="fc" id="L310">        return importKeys(ImmutableList.copyOf(keys));</span>
    }

    public boolean checkPassword(CharSequence password) {
<span class="fc bfc" id="L314" title="All 2 branches covered.">        checkState(keyCrypter != null, &quot;Not encrypted&quot;);</span>
<span class="fc" id="L315">        return checkAESKey(keyCrypter.deriveKey(password));</span>
    }

    public boolean checkAESKey(KeyParameter aesKey) {
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">        checkState(keyCrypter != null, &quot;Not encrypted&quot;);</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">        if (basic.numKeys() &gt; 0)</span>
<span class="fc" id="L321">            return basic.checkAESKey(aesKey);</span>
<span class="fc" id="L322">        return getActiveKeyChain().checkAESKey(aesKey);</span>
    }

    /** Imports the given unencrypted keys into the basic chain, encrypting them along the way with the given key. */
    public int importKeysAndEncrypt(final List&lt;ECKey&gt; keys, KeyParameter aesKey) {
        // TODO: Firstly check if the aes key can decrypt any of the existing keys successfully.
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">        checkState(keyCrypter != null, &quot;Not encrypted&quot;);</span>
<span class="fc" id="L329">        LinkedList&lt;ECKey&gt; encryptedKeys = Lists.newLinkedList();</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">        for (ECKey key : keys) {</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">            if (key.isEncrypted())</span>
<span class="fc" id="L332">                throw new IllegalArgumentException(&quot;Cannot provide already encrypted keys&quot;);</span>
<span class="fc" id="L333">            encryptedKeys.add(key.encrypt(keyCrypter, aesKey));</span>
<span class="fc" id="L334">        }</span>
<span class="fc" id="L335">        return importKeys(encryptedKeys);</span>
    }

    @Override
    @Nullable
    public RedeemData findRedeemDataFromScriptHash(byte[] scriptHash) {
        // Iterate in reverse order, since the active keychain is the one most likely to have the hit
<span class="fc bfc" id="L342" title="All 2 branches covered.">        for (Iterator&lt;DeterministicKeyChain&gt; iter = chains.descendingIterator() ; iter.hasNext() ; ) {</span>
<span class="fc" id="L343">            DeterministicKeyChain chain = iter.next();</span>
<span class="fc" id="L344">            RedeemData redeemData = chain.findRedeemDataByScriptHash(ByteString.copyFrom(scriptHash));</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">            if (redeemData != null)</span>
<span class="fc" id="L346">                return redeemData;</span>
<span class="fc" id="L347">        }</span>
<span class="fc" id="L348">        return null;</span>
    }

    public void markP2SHAddressAsUsed(Address address) {
<span class="fc" id="L352">        checkArgument(address.isP2SHAddress());</span>
<span class="fc" id="L353">        RedeemData data = findRedeemDataFromScriptHash(address.getHash160());</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">        if (data == null)</span>
<span class="fc" id="L355">            return;   // Not our P2SH address.</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">        for (ECKey key : data.keys) {</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">            for (DeterministicKeyChain chain : chains) {</span>
<span class="fc" id="L358">                DeterministicKey k = chain.findKeyFromPubKey(key.getPubKey());</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">                if (k == null) continue;</span>
<span class="fc" id="L360">                chain.markKeyAsUsed(k);</span>
<span class="fc" id="L361">                maybeMarkCurrentAddressAsUsed(address);</span>
<span class="fc" id="L362">            }</span>
<span class="fc" id="L363">        }</span>
<span class="fc" id="L364">    }</span>

    @Nullable
    @Override
    public ECKey findKeyFromPubHash(byte[] pubkeyHash) {
        ECKey result;
<span class="fc bfc" id="L370" title="All 2 branches covered.">        if ((result = basic.findKeyFromPubHash(pubkeyHash)) != null)</span>
<span class="fc" id="L371">            return result;</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains) {</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">            if ((result = chain.findKeyFromPubHash(pubkeyHash)) != null)</span>
<span class="fc" id="L374">                return result;</span>
<span class="fc" id="L375">        }</span>
<span class="fc" id="L376">        return null;</span>
    }

    /**
     * Mark the DeterministicKeys as used, if they match the pubkeyHash
     * See {@link DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     */
    public void markPubKeyHashAsUsed(byte[] pubkeyHash) {
<span class="fc bfc" id="L384" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains) {</span>
            DeterministicKey key;
<span class="fc bfc" id="L386" title="All 2 branches covered.">            if ((key = chain.markPubHashAsUsed(pubkeyHash)) != null) {</span>
<span class="fc" id="L387">                maybeMarkCurrentKeyAsUsed(key);</span>
<span class="fc" id="L388">                return;</span>
            }
<span class="fc" id="L390">        }</span>
<span class="fc" id="L391">    }</span>

    /** If the given P2SH address is &quot;current&quot;, advance it to a new one. */
    private void maybeMarkCurrentAddressAsUsed(Address address) {
<span class="fc" id="L395">        checkArgument(address.isP2SHAddress());</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">        for (Map.Entry&lt;KeyChain.KeyPurpose, Address&gt; entry : currentAddresses.entrySet()) {</span>
<span class="pc bpc" id="L397" title="1 of 4 branches missed.">            if (entry.getValue() != null &amp;&amp; entry.getValue().equals(address)) {</span>
<span class="fc" id="L398">                log.info(&quot;Marking P2SH address as used: {}&quot;, address);</span>
<span class="fc" id="L399">                currentAddresses.put(entry.getKey(), freshAddress(entry.getKey()));</span>
<span class="fc" id="L400">                return;</span>
            }
<span class="fc" id="L402">        }</span>
<span class="fc" id="L403">    }</span>

    /** If the given key is &quot;current&quot;, advance the current key to a new one. */
    private void maybeMarkCurrentKeyAsUsed(DeterministicKey key) {
        // It's OK for currentKeys to be empty here: it means we're a married wallet and the key may be a part of a
        // rotating chain.
<span class="fc bfc" id="L409" title="All 2 branches covered.">        for (Map.Entry&lt;KeyChain.KeyPurpose, DeterministicKey&gt; entry : currentKeys.entrySet()) {</span>
<span class="pc bpc" id="L410" title="1 of 4 branches missed.">            if (entry.getValue() != null &amp;&amp; entry.getValue().equals(key)) {</span>
<span class="fc" id="L411">                log.info(&quot;Marking key as used: {}&quot;, key);</span>
<span class="fc" id="L412">                currentKeys.put(entry.getKey(), freshKey(entry.getKey()));</span>
<span class="fc" id="L413">                return;</span>
            }
<span class="fc" id="L415">        }</span>
<span class="fc" id="L416">    }</span>

    public boolean hasKey(ECKey key) {
<span class="fc bfc" id="L419" title="All 2 branches covered.">        if (basic.hasKey(key))</span>
<span class="fc" id="L420">            return true;</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains)</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">            if (chain.hasKey(key))</span>
<span class="fc" id="L423">                return true;</span>
<span class="fc" id="L424">        return false;</span>
    }

    @Nullable
    @Override
    public ECKey findKeyFromPubKey(byte[] pubkey) {
        ECKey result;
<span class="fc bfc" id="L431" title="All 2 branches covered.">        if ((result = basic.findKeyFromPubKey(pubkey)) != null)</span>
<span class="fc" id="L432">            return result;</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains) {</span>
<span class="fc bfc" id="L434" title="All 2 branches covered.">            if ((result = chain.findKeyFromPubKey(pubkey)) != null)</span>
<span class="fc" id="L435">                return result;</span>
<span class="fc" id="L436">        }</span>
<span class="fc" id="L437">        return null;</span>
    }

    /**
     * Mark the DeterministicKeys as used, if they match the pubkey
     * See {@link DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     */
    public void markPubKeyAsUsed(byte[] pubkey) {
<span class="fc bfc" id="L445" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains) {</span>
            DeterministicKey key;
<span class="fc bfc" id="L447" title="All 2 branches covered.">            if ((key = chain.markPubKeyAsUsed(pubkey)) != null) {</span>
<span class="fc" id="L448">                maybeMarkCurrentKeyAsUsed(key);</span>
<span class="fc" id="L449">                return;</span>
            }
<span class="fc" id="L451">        }</span>
<span class="fc" id="L452">    }</span>

    /** Returns the number of keys managed by this group, including the lookahead buffers. */
    public int numKeys() {
<span class="fc" id="L456">        int result = basic.numKeys();</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains)</span>
<span class="fc" id="L458">            result += chain.numKeys();</span>
<span class="fc" id="L459">        return result;</span>
    }

    /**
     * Removes a key that was imported into the basic key chain. You cannot remove deterministic keys.
     * @throws java.lang.IllegalArgumentException if the key is deterministic.
     */
    public boolean removeImportedKey(ECKey key) {
<span class="fc" id="L467">        checkNotNull(key);</span>
<span class="pc bpc" id="L468" title="1 of 2 branches missed.">        checkArgument(!(key instanceof DeterministicKey));</span>
<span class="fc" id="L469">        return basic.removeKey(key);</span>
    }

    /**
     * Whether the active keychain is married.  A keychain is married when it vends P2SH addresses
     * from multiple keychains in a multisig relationship.
     * @see org.bitcoinj.wallet.MarriedKeyChain
     */
    public final boolean isMarried() {
<span class="fc bfc" id="L478" title="All 4 branches covered.">        return !chains.isEmpty() &amp;&amp; getActiveKeyChain().isMarried();</span>
    }

    /**
     * Encrypt the keys in the group using the KeyCrypter and the AES key. A good default KeyCrypter to use is
     * {@link org.bitcoinj.crypto.KeyCrypterScrypt}.
     *
     * @throws org.bitcoinj.crypto.KeyCrypterException Thrown if the wallet encryption fails for some reason,
     *         leaving the group unchanged.
     * @throws DeterministicUpgradeRequiredException Thrown if there are random keys but no HD chain.
     */
    public void encrypt(KeyCrypter keyCrypter, KeyParameter aesKey) {
<span class="fc" id="L490">        checkNotNull(keyCrypter);</span>
<span class="fc" id="L491">        checkNotNull(aesKey);</span>
        // This code must be exception safe.
<span class="fc" id="L493">        BasicKeyChain newBasic = basic.toEncrypted(keyCrypter, aesKey);</span>
<span class="fc" id="L494">        List&lt;DeterministicKeyChain&gt; newChains = new ArrayList&lt;DeterministicKeyChain&gt;(chains.size());</span>
<span class="fc bfc" id="L495" title="All 4 branches covered.">        if (chains.isEmpty() &amp;&amp; basic.numKeys() == 0) {</span>
            // No HD chains and no random keys: encrypting an entirely empty keychain group. But we can't do that, we
            // must have something to encrypt: so instantiate a new HD chain here.
<span class="fc" id="L498">            createAndActivateNewHDChain();</span>
        }
<span class="fc bfc" id="L500" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains)</span>
<span class="fc" id="L501">            newChains.add(chain.toEncrypted(keyCrypter, aesKey));</span>
<span class="fc" id="L502">        this.keyCrypter = keyCrypter;</span>
<span class="fc" id="L503">        basic = newBasic;</span>
<span class="fc" id="L504">        chains.clear();</span>
<span class="fc" id="L505">        chains.addAll(newChains);</span>
<span class="fc" id="L506">    }</span>

    /**
     * Decrypt the keys in the group using the previously given key crypter and the AES key. A good default
     * KeyCrypter to use is {@link org.bitcoinj.crypto.KeyCrypterScrypt}.
     *
     * @throws org.bitcoinj.crypto.KeyCrypterException Thrown if the wallet decryption fails for some reason, leaving the group unchanged.
     */
    public void decrypt(KeyParameter aesKey) {
        // This code must be exception safe.
<span class="fc" id="L516">        checkNotNull(aesKey);</span>
<span class="fc" id="L517">        BasicKeyChain newBasic = basic.toDecrypted(aesKey);</span>
<span class="fc" id="L518">        List&lt;DeterministicKeyChain&gt; newChains = new ArrayList&lt;DeterministicKeyChain&gt;(chains.size());</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains)</span>
<span class="fc" id="L520">            newChains.add(chain.toDecrypted(aesKey));</span>

<span class="fc" id="L522">        this.keyCrypter = null;</span>
<span class="fc" id="L523">        basic = newBasic;</span>
<span class="fc" id="L524">        chains.clear();</span>
<span class="fc" id="L525">        chains.addAll(newChains);</span>
<span class="fc" id="L526">    }</span>

    /** Returns true if the group is encrypted. */
    public boolean isEncrypted() {
<span class="fc bfc" id="L530" title="All 2 branches covered.">        return keyCrypter != null;</span>
    }

    /**
     * Returns whether this chain has only watching keys (unencrypted keys with no private part). Mixed chains are
     * forbidden.
     * 
     * @throws IllegalStateException if there are no keys, or if there is a mix between watching and non-watching keys.
     */
    public boolean isWatching() {
<span class="fc" id="L540">        BasicKeyChain.State basicState = basic.isWatching();</span>
<span class="fc" id="L541">        BasicKeyChain.State activeState = BasicKeyChain.State.EMPTY;</span>
<span class="fc bfc" id="L542" title="All 2 branches covered.">        if (!chains.isEmpty()) {</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">            if (getActiveKeyChain().isWatching())</span>
<span class="fc" id="L544">                activeState = BasicKeyChain.State.WATCHING;</span>
            else
<span class="fc" id="L546">                activeState = BasicKeyChain.State.REGULAR;</span>
        }
<span class="fc bfc" id="L548" title="All 2 branches covered.">        if (basicState == BasicKeyChain.State.EMPTY) {</span>
<span class="fc bfc" id="L549" title="All 2 branches covered.">            if (activeState == BasicKeyChain.State.EMPTY)</span>
<span class="fc" id="L550">                throw new IllegalStateException(&quot;Empty key chain group: cannot answer isWatching() query&quot;);</span>
<span class="fc bfc" id="L551" title="All 2 branches covered.">            return activeState == BasicKeyChain.State.WATCHING;</span>
<span class="fc bfc" id="L552" title="All 2 branches covered.">        } else if (activeState == BasicKeyChain.State.EMPTY)</span>
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">            return basicState == BasicKeyChain.State.WATCHING;</span>
        else {
<span class="fc bfc" id="L555" title="All 2 branches covered.">            if (activeState != basicState)</span>
<span class="fc" id="L556">                throw new IllegalStateException(&quot;Mix of watching and non-watching keys in wallet&quot;);</span>
<span class="pc bpc" id="L557" title="1 of 2 branches missed.">            return activeState == BasicKeyChain.State.WATCHING;</span>
        }
    }

    /** Returns the key crypter or null if the group is not encrypted. */
<span class="fc" id="L562">    @Nullable public KeyCrypter getKeyCrypter() { return keyCrypter; }</span>

    /**
     * Returns a list of the non-deterministic keys that have been imported into the wallet, or the empty list if none.
     */
    public List&lt;ECKey&gt; getImportedKeys() {
<span class="fc" id="L568">        return basic.getKeys();</span>
    }

    public long getEarliestKeyCreationTime() {
<span class="fc" id="L572">        long time = basic.getEarliestKeyCreationTime();   // Long.MAX_VALUE if empty.</span>
<span class="fc bfc" id="L573" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains)</span>
<span class="fc" id="L574">            time = Math.min(time, chain.getEarliestKeyCreationTime());</span>
<span class="fc" id="L575">        return time;</span>
    }

    public int getBloomFilterElementCount() {
<span class="fc" id="L579">        int result = basic.numBloomFilterEntries();</span>
<span class="fc bfc" id="L580" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains) {</span>
<span class="fc" id="L581">            result += chain.numBloomFilterEntries();</span>
<span class="fc" id="L582">        }</span>
<span class="fc" id="L583">        return result;</span>
    }

    public BloomFilter getBloomFilter(int size, double falsePositiveRate, long nTweak) {
<span class="fc" id="L587">        BloomFilter filter = new BloomFilter(size, falsePositiveRate, nTweak);</span>
<span class="fc bfc" id="L588" title="All 2 branches covered.">        if (basic.numKeys() &gt; 0)</span>
<span class="fc" id="L589">            filter.merge(basic.getFilter(size, falsePositiveRate, nTweak));</span>

<span class="fc bfc" id="L591" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains) {</span>
<span class="fc" id="L592">            filter.merge(chain.getFilter(size, falsePositiveRate, nTweak));</span>
<span class="fc" id="L593">        }</span>
<span class="fc" id="L594">        return filter;</span>
    }

    /** {@inheritDoc} */
    public boolean isRequiringUpdateAllBloomFilter() {
<span class="nc" id="L599">        throw new UnsupportedOperationException();   // Unused.</span>
    }

    private Script makeP2SHOutputScript(DeterministicKey followedKey, DeterministicKeyChain chain) {
<span class="fc" id="L603">        return ScriptBuilder.createP2SHOutputScript(chain.getRedeemData(followedKey).redeemScript);</span>
    }

    /** Adds a listener for events that are run when keys are added, on the user thread. */
    public void addEventListener(KeyChainEventListener listener) {
<span class="nc" id="L608">        addEventListener(listener, Threading.USER_THREAD);</span>
<span class="nc" id="L609">    }</span>

    /** Adds a listener for events that are run when keys are added, on the given executor. */
    public void addEventListener(KeyChainEventListener listener, Executor executor) {
<span class="fc" id="L613">        checkNotNull(listener);</span>
<span class="fc" id="L614">        checkNotNull(executor);</span>
<span class="fc" id="L615">        basic.addEventListener(listener, executor);</span>
<span class="fc bfc" id="L616" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains)</span>
<span class="fc" id="L617">            chain.addEventListener(listener, executor);</span>
<span class="fc" id="L618">    }</span>

    /** Removes a listener for events that are run when keys are added. */
    public boolean removeEventListener(KeyChainEventListener listener) {
<span class="fc" id="L622">        checkNotNull(listener);</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains)</span>
<span class="fc" id="L624">            chain.removeEventListener(listener);</span>
<span class="fc" id="L625">        return basic.removeEventListener(listener);</span>
    }

    /** Returns a list of key protobufs obtained by merging the chains. */
    public List&lt;Protos.Key&gt; serializeToProtobuf() {
        List&lt;Protos.Key&gt; result;
<span class="pc bpc" id="L631" title="1 of 2 branches missed.">        if (basic != null)</span>
<span class="fc" id="L632">            result = basic.serializeToProtobuf();</span>
        else
<span class="nc" id="L634">            result = Lists.newArrayList();</span>
<span class="fc bfc" id="L635" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains) {</span>
<span class="fc" id="L636">            List&lt;Protos.Key&gt; protos = chain.serializeToProtobuf();</span>
<span class="fc" id="L637">            result.addAll(protos);</span>
<span class="fc" id="L638">        }</span>
<span class="fc" id="L639">        return result;</span>
    }

    static KeyChainGroup fromProtobufUnencrypted(NetworkParameters params, List&lt;Protos.Key&gt; keys) throws UnreadableWalletException {
<span class="fc" id="L643">        return fromProtobufUnencrypted(params, keys, new DefaultKeyChainFactory());</span>
    }

    public static KeyChainGroup fromProtobufUnencrypted(NetworkParameters params, List&lt;Protos.Key&gt; keys, KeyChainFactory factory) throws UnreadableWalletException {
<span class="fc" id="L647">        BasicKeyChain basicKeyChain = BasicKeyChain.fromProtobufUnencrypted(keys);</span>
<span class="fc" id="L648">        List&lt;DeterministicKeyChain&gt; chains = DeterministicKeyChain.fromProtobuf(keys, null, factory);</span>
<span class="fc" id="L649">        EnumMap&lt;KeyChain.KeyPurpose, DeterministicKey&gt; currentKeys = null;</span>
<span class="fc bfc" id="L650" title="All 2 branches covered.">        if (!chains.isEmpty())</span>
<span class="fc" id="L651">            currentKeys = createCurrentKeysMap(chains);</span>
<span class="fc" id="L652">        extractFollowingKeychains(chains);</span>
<span class="fc" id="L653">        return new KeyChainGroup(params, basicKeyChain, chains, currentKeys, null);</span>
    }

    static KeyChainGroup fromProtobufEncrypted(NetworkParameters params, List&lt;Protos.Key&gt; keys, KeyCrypter crypter) throws UnreadableWalletException {
<span class="fc" id="L657">        return fromProtobufEncrypted(params, keys, crypter, new DefaultKeyChainFactory());</span>
    }

    public static KeyChainGroup fromProtobufEncrypted(NetworkParameters params, List&lt;Protos.Key&gt; keys, KeyCrypter crypter, KeyChainFactory factory) throws UnreadableWalletException {
<span class="fc" id="L661">        checkNotNull(crypter);</span>
<span class="fc" id="L662">        BasicKeyChain basicKeyChain = BasicKeyChain.fromProtobufEncrypted(keys, crypter);</span>
<span class="fc" id="L663">        List&lt;DeterministicKeyChain&gt; chains = DeterministicKeyChain.fromProtobuf(keys, crypter, factory);</span>
<span class="fc" id="L664">        EnumMap&lt;KeyChain.KeyPurpose, DeterministicKey&gt; currentKeys = null;</span>
<span class="pc bpc" id="L665" title="1 of 2 branches missed.">        if (!chains.isEmpty())</span>
<span class="fc" id="L666">            currentKeys = createCurrentKeysMap(chains);</span>
<span class="fc" id="L667">        extractFollowingKeychains(chains);</span>
<span class="fc" id="L668">        return new KeyChainGroup(params, basicKeyChain, chains, currentKeys, crypter);</span>
    }

    /**
     * If the key chain contains only random keys and no deterministic key chains, this method will create a chain
     * based on the oldest non-rotating private key (i.e. the seed is derived from the old wallet).
     *
     * @param keyRotationTimeSecs If non-zero, UNIX time for which keys created before this are assumed to be
     *                            compromised or weak, those keys will not be used for deterministic upgrade.
     * @param aesKey If non-null, the encryption key the keychain is encrypted under. If the keychain is encrypted
     *               and this is not supplied, an exception is thrown letting you know you should ask the user for
     *               their password, turn it into a key, and then try again.
     * @throws java.lang.IllegalStateException if there is already a deterministic key chain present or if there are
     *                                         no random keys (i.e. this is not an upgrade scenario), or if aesKey is
     *                                         provided but the wallet is not encrypted.
     * @throws java.lang.IllegalArgumentException if the rotation time specified excludes all keys.
     * @throws DeterministicUpgradeRequiresPassword if the key chain group is encrypted
     *         and you should provide the users encryption key.
     * @return the DeterministicKeyChain that was created by the upgrade.
     */
    public DeterministicKeyChain upgradeToDeterministic(long keyRotationTimeSecs, @Nullable KeyParameter aesKey) throws DeterministicUpgradeRequiresPassword, AllRandomKeysRotating {
<span class="pc bpc" id="L689" title="1 of 2 branches missed.">        checkState(basic.numKeys() &gt; 0);</span>
<span class="pc bpc" id="L690" title="1 of 2 branches missed.">        checkArgument(keyRotationTimeSecs &gt;= 0);</span>
        // Subtract one because the key rotation time might have been set to the creation time of the first known good
        // key, in which case, that's the one we want to find.
<span class="fc" id="L693">        ECKey keyToUse = basic.findOldestKeyAfter(keyRotationTimeSecs - 1);</span>
<span class="pc bpc" id="L694" title="1 of 2 branches missed.">        if (keyToUse == null)</span>
<span class="nc" id="L695">            throw new AllRandomKeysRotating();</span>

<span class="fc bfc" id="L697" title="All 2 branches covered.">        if (keyToUse.isEncrypted()) {</span>
<span class="fc bfc" id="L698" title="All 2 branches covered.">            if (aesKey == null) {</span>
                // We can't auto upgrade because we don't know the users password at this point. We throw an
                // exception so the calling code knows to abort the load and ask the user for their password, they can
                // then try loading the wallet again passing in the AES key.
                //
                // There are a few different approaches we could have used here, but they all suck. The most obvious
                // is to try and be as lazy as possible, running in the old random-wallet mode until the user enters
                // their password for some other reason and doing the upgrade then. But this could result in strange
                // and unexpected UI flows for the user, as well as complicating the job of wallet developers who then
                // have to support both &quot;old&quot; and &quot;new&quot; UI modes simultaneously, switching them on the fly. Given that
                // this is a one-off transition, it seems more reasonable to just ask the user for their password
                // on startup, and then the wallet app can have all the widgets for accessing seed words etc active
                // all the time.
<span class="fc" id="L711">                throw new DeterministicUpgradeRequiresPassword();</span>
            }
<span class="fc" id="L713">            keyToUse = keyToUse.decrypt(aesKey);</span>
<span class="pc bpc" id="L714" title="1 of 2 branches missed.">        } else if (aesKey != null) {</span>
<span class="nc" id="L715">            throw new IllegalStateException(&quot;AES Key was provided but wallet is not encrypted.&quot;);</span>
        }

<span class="fc bfc" id="L718" title="All 2 branches covered.">        if (chains.isEmpty()) {</span>
<span class="fc" id="L719">            log.info(&quot;Auto-upgrading pre-HD wallet to HD!&quot;);</span>
        } else {
<span class="fc" id="L721">            log.info(&quot;Wallet with existing HD chain is being re-upgraded due to change in key rotation time.&quot;);</span>
        }
<span class="fc" id="L723">        log.info(&quot;Instantiating new HD chain using oldest non-rotating private key (address: {})&quot;, keyToUse.toAddress(params));</span>
<span class="fc" id="L724">        byte[] entropy = checkNotNull(keyToUse.getSecretBytes());</span>
        // Private keys should be at least 128 bits long.
<span class="pc bpc" id="L726" title="1 of 2 branches missed.">        checkState(entropy.length &gt;= DeterministicSeed.DEFAULT_SEED_ENTROPY_BITS / 8);</span>
        // We reduce the entropy here to 128 bits because people like to write their seeds down on paper, and 128
        // bits should be sufficient forever unless the laws of the universe change or ECC is broken; in either case
        // we all have bigger problems.
<span class="fc" id="L730">        entropy = Arrays.copyOfRange(entropy, 0, DeterministicSeed.DEFAULT_SEED_ENTROPY_BITS / 8);    // final argument is exclusive range.</span>
<span class="pc bpc" id="L731" title="1 of 2 branches missed.">        checkState(entropy.length == DeterministicSeed.DEFAULT_SEED_ENTROPY_BITS / 8);</span>
<span class="fc" id="L732">        String passphrase = &quot;&quot;; // FIXME allow non-empty passphrase</span>
<span class="fc" id="L733">        DeterministicKeyChain chain = new DeterministicKeyChain(entropy, passphrase, keyToUse.getCreationTimeSeconds());</span>
<span class="fc bfc" id="L734" title="All 2 branches covered.">        if (aesKey != null) {</span>
<span class="fc" id="L735">            chain = chain.toEncrypted(checkNotNull(basic.getKeyCrypter()), aesKey);</span>
        }
<span class="fc" id="L737">        chains.add(chain);</span>
<span class="fc" id="L738">        return chain;</span>
    }

    /** Returns true if the group contains random keys but no HD chains. */
    public boolean isDeterministicUpgradeRequired() {
<span class="fc bfc" id="L743" title="All 4 branches covered.">        return basic.numKeys() &gt; 0 &amp;&amp; chains.isEmpty();</span>
    }

    private static EnumMap&lt;KeyChain.KeyPurpose, DeterministicKey&gt; createCurrentKeysMap(List&lt;DeterministicKeyChain&gt; chains) {
<span class="fc" id="L747">        DeterministicKeyChain activeChain = chains.get(chains.size() - 1);</span>

<span class="fc" id="L749">        EnumMap&lt;KeyChain.KeyPurpose, DeterministicKey&gt; currentKeys = new EnumMap&lt;KeyChain.KeyPurpose, DeterministicKey&gt;(KeyChain.KeyPurpose.class);</span>

        // assuming that only RECEIVE and CHANGE keys are being used at the moment, we will treat latest issued external key
        // as current RECEIVE key and latest issued internal key as CHANGE key. This should be changed as soon as other
        // kinds of KeyPurpose are introduced.
<span class="fc bfc" id="L754" title="All 2 branches covered.">        if (activeChain.getIssuedExternalKeys() &gt; 0) {</span>
<span class="fc" id="L755">            DeterministicKey currentExternalKey = activeChain.getKeyByPath(</span>
<span class="fc" id="L756">                    HDUtils.append(</span>
<span class="fc" id="L757">                            HDUtils.concat(activeChain.getAccountPath(), DeterministicKeyChain.EXTERNAL_SUBPATH),</span>
<span class="fc" id="L758">                            new ChildNumber(activeChain.getIssuedExternalKeys() - 1)));</span>
<span class="fc" id="L759">            currentKeys.put(KeyChain.KeyPurpose.RECEIVE_FUNDS, currentExternalKey);</span>
        }

<span class="fc bfc" id="L762" title="All 2 branches covered.">        if (activeChain.getIssuedInternalKeys() &gt; 0) {</span>
<span class="fc" id="L763">            DeterministicKey currentInternalKey = activeChain.getKeyByPath(</span>
<span class="fc" id="L764">                    HDUtils.append(</span>
<span class="fc" id="L765">                            HDUtils.concat(activeChain.getAccountPath(), DeterministicKeyChain.INTERNAL_SUBPATH),</span>
<span class="fc" id="L766">                            new ChildNumber(activeChain.getIssuedInternalKeys() - 1)));</span>
<span class="fc" id="L767">            currentKeys.put(KeyChain.KeyPurpose.CHANGE, currentInternalKey);</span>
        }
<span class="fc" id="L769">        return currentKeys;</span>
    }

    private static void extractFollowingKeychains(List&lt;DeterministicKeyChain&gt; chains) {
        // look for following key chains and map them to the watch keys of followed keychains
<span class="fc" id="L774">        List&lt;DeterministicKeyChain&gt; followingChains = Lists.newArrayList();</span>
<span class="fc bfc" id="L775" title="All 2 branches covered.">        for (Iterator&lt;DeterministicKeyChain&gt; it = chains.iterator(); it.hasNext(); ) {</span>
<span class="fc" id="L776">            DeterministicKeyChain chain = it.next();</span>
<span class="fc bfc" id="L777" title="All 2 branches covered.">            if (chain.isFollowing()) {</span>
<span class="fc" id="L778">                followingChains.add(chain);</span>
<span class="fc" id="L779">                it.remove();</span>
<span class="fc bfc" id="L780" title="All 2 branches covered.">            } else if (!followingChains.isEmpty()) {</span>
<span class="pc bpc" id="L781" title="1 of 2 branches missed.">                if (!(chain instanceof MarriedKeyChain))</span>
<span class="nc" id="L782">                    throw new IllegalStateException();</span>
<span class="fc" id="L783">                ((MarriedKeyChain)chain).setFollowingKeyChains(followingChains);</span>
<span class="fc" id="L784">                followingChains = Lists.newArrayList();</span>
            }
<span class="fc" id="L786">        }</span>
<span class="fc" id="L787">    }</span>

    public String toString(boolean includePrivateKeys) {
<span class="fc" id="L790">        final StringBuilder builder = new StringBuilder();</span>
<span class="pc bpc" id="L791" title="1 of 2 branches missed.">        if (basic != null) {</span>
<span class="fc" id="L792">            List&lt;ECKey&gt; keys = basic.getKeys();</span>
<span class="fc" id="L793">            Collections.sort(keys, ECKey.AGE_COMPARATOR);</span>
<span class="pc bpc" id="L794" title="1 of 2 branches missed.">            for (ECKey key : keys)</span>
<span class="nc" id="L795">                key.formatKeyWithAddress(includePrivateKeys, builder, params);</span>
        }
<span class="fc bfc" id="L797" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains)</span>
<span class="fc" id="L798">            builder.append(chain.toString(includePrivateKeys, params)).append('\n');</span>
<span class="fc" id="L799">        return builder.toString();</span>
    }

    /** Returns a copy of the current list of chains. */
    public List&lt;DeterministicKeyChain&gt; getDeterministicKeyChains() {
<span class="fc" id="L804">        return new ArrayList&lt;DeterministicKeyChain&gt;(chains);</span>
    }
    /**
     * Returns a counter that increases (by an arbitrary amount) each time new keys have been calculated due to
     * lookahead and thus the Bloom filter that was previously calculated has become stale.
     */
    public int getCombinedKeyLookaheadEpochs() {
<span class="fc" id="L811">        int epoch = 0;</span>
<span class="fc bfc" id="L812" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains)</span>
<span class="fc" id="L813">            epoch += chain.getKeyLookaheadEpoch();</span>
<span class="fc" id="L814">        return epoch;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>