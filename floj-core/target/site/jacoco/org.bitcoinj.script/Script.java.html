<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Script.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">bitcoinj</a> &gt; <a href="index.source.html" class="el_package">org.bitcoinj.script</a> &gt; <span class="el_source">Script.java</span></div><h1>Script.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2011 Google Inc.
 * Copyright 2012 Matt Corallo.
 * Copyright 2014 Andreas Schildbach
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.bitcoinj.script;

import org.bitcoinj.core.*;
import org.bitcoinj.crypto.TransactionSignature;
import com.google.common.collect.Lists;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.spongycastle.crypto.digests.RIPEMD160Digest;

import javax.annotation.Nullable;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.*;

import static org.bitcoinj.script.ScriptOpCodes.*;
import static com.google.common.base.Preconditions.*;

// TODO: Redesign this entire API to be more type safe and organised.

/**
 * &lt;p&gt;Programs embedded inside transactions that control redemption of payments.&lt;/p&gt;
 *
 * &lt;p&gt;FLO transactions don't specify what they do directly. Instead &lt;a href=&quot;https://en.bitcoin.it/wiki/Script&quot;&gt;a
 * small binary stack language&lt;/a&gt; is used to define programs that when evaluated return whether the transaction
 * &quot;accepts&quot; or rejects the other transactions connected to it.&lt;/p&gt;
 *
 * &lt;p&gt;In SPV mode, scripts are not run, because that would require all transactions to be available and lightweight
 * clients don't have that data. In full mode, this class is used to run the interpreted language. It also has
 * static methods for building scripts.&lt;/p&gt;
 */
public class Script {

    /** Enumeration to encapsulate the type of this script. */
<span class="pc" id="L57">    public enum ScriptType {</span>
        // Do NOT change the ordering of the following definitions because their ordinals are stored in databases.
<span class="fc" id="L59">        NO_TYPE,</span>
<span class="fc" id="L60">        P2PKH,</span>
<span class="fc" id="L61">        PUB_KEY,</span>
<span class="fc" id="L62">        P2SH</span>
    }

    /** Flags to pass to {@link Script#correctlySpends(Transaction, long, Script, Set)}.
     * Note currently only P2SH, DERSIG and NULLDUMMY are actually supported.
     */
<span class="fc" id="L68">    public enum VerifyFlag {</span>
<span class="fc" id="L69">        P2SH, // Enable BIP16-style subscript evaluation.</span>
<span class="fc" id="L70">        STRICTENC, // Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.</span>
<span class="fc" id="L71">        DERSIG, // Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, BIP66 rule 1)</span>
<span class="fc" id="L72">        LOW_S, // Passing a non-strict-DER signature or one with S &gt; order/2 to a checksig operation causes script failure</span>
<span class="fc" id="L73">        NULLDUMMY, // Verify dummy stack item consumed by CHECKMULTISIG is of zero-length.</span>
<span class="fc" id="L74">        SIGPUSHONLY, // Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).</span>
<span class="fc" id="L75">        MINIMALDATA, // Require minimal encodings for all push operations</span>
<span class="fc" id="L76">        DISCOURAGE_UPGRADABLE_NOPS, // Discourage use of NOPs reserved for upgrades (NOP1-10)</span>
<span class="fc" id="L77">        CLEANSTACK, // Require that only a single stack element remains after evaluation.</span>
<span class="fc" id="L78">        CHECKLOCKTIMEVERIFY // Enable CHECKLOCKTIMEVERIFY operation</span>
    }
<span class="fc" id="L80">    public static final EnumSet&lt;VerifyFlag&gt; ALL_VERIFY_FLAGS = EnumSet.allOf(VerifyFlag.class);</span>

<span class="fc" id="L82">    private static final Logger log = LoggerFactory.getLogger(Script.class);</span>
    public static final long MAX_SCRIPT_ELEMENT_SIZE = 520;  // bytes
    public static final int SIG_SIZE = 75;
    /** Max number of sigops allowed in a standard p2sh redeem script */
    public static final int MAX_P2SH_SIGOPS = 15;

    // The program is a set of chunks where each element is either [opcode] or [data, data, data ...]
    protected List&lt;ScriptChunk&gt; chunks;
    // Unfortunately, scripts are not ever re-serialized or canonicalized when used in signature hashing. Thus we
    // must preserve the exact bytes that we read off the wire, along with the parsed form.
    protected byte[] program;

    // Creation time of the associated keys in seconds since the epoch.
    private long creationTimeSeconds;

    /** Creates an empty script that serializes to nothing. */
<span class="fc" id="L98">    private Script() {</span>
<span class="fc" id="L99">        chunks = Lists.newArrayList();</span>
<span class="fc" id="L100">    }</span>

    // Used from ScriptBuilder.
<span class="fc" id="L103">    Script(List&lt;ScriptChunk&gt; chunks) {</span>
<span class="fc" id="L104">        this.chunks = Collections.unmodifiableList(new ArrayList&lt;ScriptChunk&gt;(chunks));</span>
<span class="fc" id="L105">        creationTimeSeconds = Utils.currentTimeSeconds();</span>
<span class="fc" id="L106">    }</span>

    /**
     * Construct a Script that copies and wraps the programBytes array. The array is parsed and checked for syntactic
     * validity.
     * @param programBytes Array of program bytes from a transaction.
     */
<span class="fc" id="L113">    public Script(byte[] programBytes) throws ScriptException {</span>
<span class="fc" id="L114">        program = programBytes;</span>
<span class="fc" id="L115">        parse(programBytes);</span>
<span class="fc" id="L116">        creationTimeSeconds = 0;</span>
<span class="fc" id="L117">    }</span>

<span class="fc" id="L119">    public Script(byte[] programBytes, long creationTimeSeconds) throws ScriptException {</span>
<span class="fc" id="L120">        program = programBytes;</span>
<span class="fc" id="L121">        parse(programBytes);</span>
<span class="fc" id="L122">        this.creationTimeSeconds = creationTimeSeconds;</span>
<span class="fc" id="L123">    }</span>

    public long getCreationTimeSeconds() {
<span class="fc" id="L126">        return creationTimeSeconds;</span>
    }

    public void setCreationTimeSeconds(long creationTimeSeconds) {
<span class="fc" id="L130">        this.creationTimeSeconds = creationTimeSeconds;</span>
<span class="fc" id="L131">    }</span>

    /**
     * Returns the program opcodes as a string, for example &quot;[1234] DUP HASH160&quot;
     */
    @Override
    public String toString() {
<span class="fc" id="L138">        return Utils.join(chunks);</span>
    }

    /** Returns the serialized program as a newly created byte array. */
    public byte[] getProgram() {
        try {
            // Don't round-trip as FLO Core doesn't and it would introduce a mismatch.
<span class="fc bfc" id="L145" title="All 2 branches covered.">            if (program != null)</span>
<span class="fc" id="L146">                return Arrays.copyOf(program, program.length);</span>
<span class="fc" id="L147">            ByteArrayOutputStream bos = new ByteArrayOutputStream();</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">            for (ScriptChunk chunk : chunks) {</span>
<span class="fc" id="L149">                chunk.write(bos);</span>
<span class="fc" id="L150">            }</span>
<span class="fc" id="L151">            program = bos.toByteArray();</span>
<span class="fc" id="L152">            return program;</span>
<span class="nc" id="L153">        } catch (IOException e) {</span>
<span class="nc" id="L154">            throw new RuntimeException(e);  // Cannot happen.</span>
        }
    }

    /** Returns an immutable list of the scripts parsed form. Each chunk is either an opcode or data element. */
    public List&lt;ScriptChunk&gt; getChunks() {
<span class="fc" id="L160">        return Collections.unmodifiableList(chunks);</span>
    }

<span class="fc" id="L163">    private static final ScriptChunk[] STANDARD_TRANSACTION_SCRIPT_CHUNKS = {</span>
        new ScriptChunk(ScriptOpCodes.OP_DUP, null, 0),
        new ScriptChunk(ScriptOpCodes.OP_HASH160, null, 1),
        new ScriptChunk(ScriptOpCodes.OP_EQUALVERIFY, null, 23),
        new ScriptChunk(ScriptOpCodes.OP_CHECKSIG, null, 24),
    };

    /**
     * &lt;p&gt;To run a script, first we parse it which breaks it up into chunks representing pushes of data or logical
     * opcodes. Then we can run the parsed chunks.&lt;/p&gt;
     *
     * &lt;p&gt;The reason for this split, instead of just interpreting directly, is to make it easier
     * to reach into a programs structure and pull out bits of data without having to run it.
     * This is necessary to render the to/from addresses of transactions in a user interface.
     * FLO Core does something similar.&lt;/p&gt;
     */
    private void parse(byte[] program) throws ScriptException {
<span class="fc" id="L180">        chunks = new ArrayList&lt;ScriptChunk&gt;(5);   // Common size.</span>
<span class="fc" id="L181">        ByteArrayInputStream bis = new ByteArrayInputStream(program);</span>
<span class="fc" id="L182">        int initialSize = bis.available();</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">        while (bis.available() &gt; 0) {</span>
<span class="fc" id="L184">            int startLocationInProgram = initialSize - bis.available();</span>
<span class="fc" id="L185">            int opcode = bis.read();</span>

<span class="fc" id="L187">            long dataToRead = -1;</span>
<span class="pc bpc" id="L188" title="1 of 4 branches missed.">            if (opcode &gt;= 0 &amp;&amp; opcode &lt; OP_PUSHDATA1) {</span>
                // Read some bytes of data, where how many is the opcode value itself.
<span class="fc" id="L190">                dataToRead = opcode;</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">            } else if (opcode == OP_PUSHDATA1) {</span>
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">                if (bis.available() &lt; 1) throw new ScriptException(&quot;Unexpected end of script&quot;);</span>
<span class="fc" id="L193">                dataToRead = bis.read();</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">            } else if (opcode == OP_PUSHDATA2) {</span>
                // Read a short, then read that many bytes of data.
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">                if (bis.available() &lt; 2) throw new ScriptException(&quot;Unexpected end of script&quot;);</span>
<span class="fc" id="L197">                dataToRead = bis.read() | (bis.read() &lt;&lt; 8);</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">            } else if (opcode == OP_PUSHDATA4) {</span>
                // Read a uint32, then read that many bytes of data.
                // Though this is allowed, because its value cannot be &gt; 520, it should never actually be used
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">                if (bis.available() &lt; 4) throw new ScriptException(&quot;Unexpected end of script&quot;);</span>
<span class="fc" id="L202">                dataToRead = ((long)bis.read()) | (((long)bis.read()) &lt;&lt; 8) | (((long)bis.read()) &lt;&lt; 16) | (((long)bis.read()) &lt;&lt; 24);</span>
            }

            ScriptChunk chunk;
<span class="fc bfc" id="L206" title="All 2 branches covered.">            if (dataToRead == -1) {</span>
<span class="fc" id="L207">                chunk = new ScriptChunk(opcode, null, startLocationInProgram);</span>
            } else {
<span class="fc bfc" id="L209" title="All 2 branches covered.">                if (dataToRead &gt; bis.available())</span>
<span class="fc" id="L210">                    throw new ScriptException(&quot;Push of data element that is larger than remaining data&quot;);</span>
<span class="fc" id="L211">                byte[] data = new byte[(int)dataToRead];</span>
<span class="pc bpc" id="L212" title="1 of 4 branches missed.">                checkState(dataToRead == 0 || bis.read(data, 0, (int)dataToRead) == dataToRead);</span>
<span class="fc" id="L213">                chunk = new ScriptChunk(opcode, data, startLocationInProgram);</span>
            }
            // Save some memory by eliminating redundant copies of the same chunk objects.
<span class="fc bfc" id="L216" title="All 2 branches covered.">            for (ScriptChunk c : STANDARD_TRANSACTION_SCRIPT_CHUNKS) {</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">                if (c.equals(chunk)) chunk = c;</span>
            }
<span class="fc" id="L219">            chunks.add(chunk);</span>
<span class="fc" id="L220">        }</span>
<span class="fc" id="L221">    }</span>

    /**
     * Returns true if this script is of the form &lt;pubkey&gt; OP_CHECKSIG. This form was originally intended for transactions
     * where the peers talked to each other directly via TCP/IP, but has fallen out of favor with time due to that mode
     * of operation being susceptible to man-in-the-middle attacks. It is still used in coinbase outputs and can be
     * useful more exotic types of transaction, but today most payments are to addresses.
     */
    public boolean isSentToRawPubKey() {
<span class="fc bfc" id="L230" title="All 4 branches covered.">        return chunks.size() == 2 &amp;&amp; chunks.get(1).equalsOpCode(OP_CHECKSIG) &amp;&amp;</span>
<span class="pc bpc" id="L231" title="2 of 4 branches missed.">               !chunks.get(0).isOpCode() &amp;&amp; chunks.get(0).data.length &gt; 1;</span>
    }

    /**
     * Returns true if this script is of the form DUP HASH160 &lt;pubkey hash&gt; EQUALVERIFY CHECKSIG, ie, payment to an
     * address like 1VayNert3x1KzbpzMGt2qdqrAThiRovi8. This form was originally intended for the case where you wish
     * to send somebody money with a written code because their node is offline, but over time has become the standard
     * way to make payments due to the short and recognizable base58 form addresses come in.
     */
    public boolean isSentToAddress() {
<span class="fc bfc" id="L241" title="All 2 branches covered.">        return chunks.size() == 5 &amp;&amp;</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">               chunks.get(0).equalsOpCode(OP_DUP) &amp;&amp;</span>
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">               chunks.get(1).equalsOpCode(OP_HASH160) &amp;&amp;</span>
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">               chunks.get(2).data.length == Address.LENGTH &amp;&amp;</span>
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">               chunks.get(3).equalsOpCode(OP_EQUALVERIFY) &amp;&amp;</span>
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">               chunks.get(4).equalsOpCode(OP_CHECKSIG);</span>
    }

    /**
     * An alias for isPayToScriptHash.
     */
    @Deprecated
    public boolean isSentToP2SH() {
<span class="nc" id="L254">        return isPayToScriptHash();</span>
    }

    /**
     * &lt;p&gt;If a program matches the standard template DUP HASH160 &amp;lt;pubkey hash&amp;gt; EQUALVERIFY CHECKSIG
     * then this function retrieves the third element.
     * In this case, this is useful for fetching the destination address of a transaction.&lt;/p&gt;
     * 
     * &lt;p&gt;If a program matches the standard template HASH160 &amp;lt;script hash&amp;gt; EQUAL
     * then this function retrieves the second element.
     * In this case, this is useful for fetching the hash of the redeem script of a transaction.&lt;/p&gt;
     * 
     * &lt;p&gt;Otherwise it throws a ScriptException.&lt;/p&gt;
     *
     */
    public byte[] getPubKeyHash() throws ScriptException {
<span class="fc bfc" id="L270" title="All 2 branches covered.">        if (isSentToAddress())</span>
<span class="fc" id="L271">            return chunks.get(2).data;</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">        else if (isPayToScriptHash())</span>
<span class="fc" id="L273">            return chunks.get(1).data;</span>
        else
<span class="fc" id="L275">            throw new ScriptException(&quot;Script not in the standard scriptPubKey form&quot;);</span>
    }

    /**
     * Returns the public key in this script. If a script contains two constants and nothing else, it is assumed to
     * be a scriptSig (input) for a pay-to-address output and the second constant is returned (the first is the
     * signature). If a script contains a constant and an OP_CHECKSIG opcode, the constant is returned as it is
     * assumed to be a direct pay-to-key scriptPubKey (output) and the first constant is the public key.
     *
     * @throws ScriptException if the script is none of the named forms.
     */
    public byte[] getPubKey() throws ScriptException {
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">        if (chunks.size() != 2) {</span>
<span class="nc" id="L288">            throw new ScriptException(&quot;Script not of right size, expecting 2 but got &quot; + chunks.size());</span>
        }
<span class="fc" id="L290">        final ScriptChunk chunk0 = chunks.get(0);</span>
<span class="fc" id="L291">        final byte[] chunk0data = chunk0.data;</span>
<span class="fc" id="L292">        final ScriptChunk chunk1 = chunks.get(1);</span>
<span class="fc" id="L293">        final byte[] chunk1data = chunk1.data;</span>
<span class="pc bpc" id="L294" title="3 of 8 branches missed.">        if (chunk0data != null &amp;&amp; chunk0data.length &gt; 2 &amp;&amp; chunk1data != null &amp;&amp; chunk1data.length &gt; 2) {</span>
            // If we have two large constants assume the input to a pay-to-address output.
<span class="fc" id="L296">            return chunk1data;</span>
<span class="pc bpc" id="L297" title="3 of 6 branches missed.">        } else if (chunk1.equalsOpCode(OP_CHECKSIG) &amp;&amp; chunk0data != null &amp;&amp; chunk0data.length &gt; 2) {</span>
            // A large constant followed by an OP_CHECKSIG is the key.
<span class="fc" id="L299">            return chunk0data;</span>
        } else {
<span class="nc" id="L301">            throw new ScriptException(&quot;Script did not match expected form: &quot; + this);</span>
        }
    }

    /**
     * Retrieves the sender public key from a LOCKTIMEVERIFY transaction
     * @return
     * @throws ScriptException
     */
    public byte[] getCLTVPaymentChannelSenderPubKey() throws ScriptException {
<span class="nc bnc" id="L311" title="All 2 branches missed.">        if (!isSentToCLTVPaymentChannel()) {</span>
<span class="nc" id="L312">            throw new ScriptException(&quot;Script not a standard CHECKLOCKTIMVERIFY transaction: &quot; + this);</span>
        }
<span class="nc" id="L314">        return chunks.get(8).data;</span>
    }

    /**
     * Retrieves the recipient public key from a LOCKTIMEVERIFY transaction
     * @return
     * @throws ScriptException
     */
    public byte[] getCLTVPaymentChannelRecipientPubKey() throws ScriptException {
<span class="nc bnc" id="L323" title="All 2 branches missed.">        if (!isSentToCLTVPaymentChannel()) {</span>
<span class="nc" id="L324">            throw new ScriptException(&quot;Script not a standard CHECKLOCKTIMVERIFY transaction: &quot; + this);</span>
        }
<span class="nc" id="L326">        return chunks.get(1).data;</span>
    }

    public BigInteger getCLTVPaymentChannelExpiry() {
<span class="nc bnc" id="L330" title="All 2 branches missed.">        if (!isSentToCLTVPaymentChannel()) {</span>
<span class="nc" id="L331">            throw new ScriptException(&quot;Script not a standard CHECKLOCKTIMEVERIFY transaction: &quot; + this);</span>
        }
<span class="nc" id="L333">        return castToBigInteger(chunks.get(4).data, 5);</span>
    }

    /**
     * For 2-element [input] scripts assumes that the paid-to-address can be derived from the public key.
     * The concept of a &quot;from address&quot; isn't well defined in FLO and you should not assume the sender of a
     * transaction can actually receive coins on it. This method may be removed in future.
     */
    @Deprecated
    public Address getFromAddress(NetworkParameters params) throws ScriptException {
<span class="fc" id="L343">        return new Address(params, Utils.sha256hash160(getPubKey()));</span>
    }

    /**
     * Gets the destination address from this script, if it's in the required form (see getPubKey).
     */
    public Address getToAddress(NetworkParameters params) throws ScriptException {
<span class="fc" id="L350">        return getToAddress(params, false);</span>
    }

    /**
     * Gets the destination address from this script, if it's in the required form (see getPubKey).
     * 
     * @param forcePayToPubKey
     *            If true, allow payToPubKey to be casted to the corresponding address. This is useful if you prefer
     *            showing addresses rather than pubkeys.
     */
    public Address getToAddress(NetworkParameters params, boolean forcePayToPubKey) throws ScriptException {
<span class="fc bfc" id="L361" title="All 2 branches covered.">        if (isSentToAddress())</span>
<span class="fc" id="L362">            return new Address(params, getPubKeyHash());</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">        else if (isPayToScriptHash())</span>
<span class="fc" id="L364">            return Address.fromP2SHScript(params, this);</span>
<span class="fc bfc" id="L365" title="All 4 branches covered.">        else if (forcePayToPubKey &amp;&amp; isSentToRawPubKey())</span>
<span class="fc" id="L366">            return ECKey.fromPublicOnly(getPubKey()).toAddress(params);</span>
        else
<span class="fc" id="L368">            throw new ScriptException(&quot;Cannot cast this script to a pay-to-address type&quot;);</span>
    }

    ////////////////////// Interface for writing scripts from scratch ////////////////////////////////

    /**
     * Writes out the given byte buffer to the output stream with the correct opcode prefix
     * To write an integer call writeBytes(out, Utils.reverseBytes(Utils.encodeMPI(val, false)));
     */
    public static void writeBytes(OutputStream os, byte[] buf) throws IOException {
<span class="fc bfc" id="L378" title="All 2 branches covered.">        if (buf.length &lt; OP_PUSHDATA1) {</span>
<span class="fc" id="L379">            os.write(buf.length);</span>
<span class="fc" id="L380">            os.write(buf);</span>
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">        } else if (buf.length &lt; 256) {</span>
<span class="nc" id="L382">            os.write(OP_PUSHDATA1);</span>
<span class="nc" id="L383">            os.write(buf.length);</span>
<span class="nc" id="L384">            os.write(buf);</span>
<span class="pc bpc" id="L385" title="1 of 2 branches missed.">        } else if (buf.length &lt; 65536) {</span>
<span class="fc" id="L386">            os.write(OP_PUSHDATA2);</span>
<span class="fc" id="L387">            os.write(0xFF &amp; (buf.length));</span>
<span class="fc" id="L388">            os.write(0xFF &amp; (buf.length &gt;&gt; 8));</span>
<span class="fc" id="L389">            os.write(buf);</span>
        } else {
<span class="nc" id="L391">            throw new RuntimeException(&quot;Unimplemented&quot;);</span>
        }
<span class="fc" id="L393">    }</span>

    /** Creates a program that requires at least N of the given keys to sign, using OP_CHECKMULTISIG. */
    public static byte[] createMultiSigOutputScript(int threshold, List&lt;ECKey&gt; pubkeys) {
<span class="fc bfc" id="L397" title="All 2 branches covered.">        checkArgument(threshold &gt; 0);</span>
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">        checkArgument(threshold &lt;= pubkeys.size());</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">        checkArgument(pubkeys.size() &lt;= 16);  // That's the max we can represent with a single opcode.</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">        if (pubkeys.size() &gt; 3) {</span>
<span class="nc" id="L401">            log.warn(&quot;Creating a multi-signature output that is non-standard: {} pubkeys, should be &lt;= 3&quot;, pubkeys.size());</span>
        }
        try {
<span class="nc" id="L404">            ByteArrayOutputStream bits = new ByteArrayOutputStream();</span>
<span class="nc" id="L405">            bits.write(encodeToOpN(threshold));</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">            for (ECKey key : pubkeys) {</span>
<span class="nc" id="L407">                writeBytes(bits, key.getPubKey());</span>
<span class="nc" id="L408">            }</span>
<span class="nc" id="L409">            bits.write(encodeToOpN(pubkeys.size()));</span>
<span class="nc" id="L410">            bits.write(OP_CHECKMULTISIG);</span>
<span class="nc" id="L411">            return bits.toByteArray();</span>
<span class="nc" id="L412">        } catch (IOException e) {</span>
<span class="nc" id="L413">            throw new RuntimeException(e);  // Cannot happen.</span>
        }
    }

    public static byte[] createInputScript(byte[] signature, byte[] pubkey) {
        try {
            // TODO: Do this by creating a Script *first* then having the script reassemble itself into bytes.
<span class="fc" id="L420">            ByteArrayOutputStream bits = new UnsafeByteArrayOutputStream(signature.length + pubkey.length + 2);</span>
<span class="fc" id="L421">            writeBytes(bits, signature);</span>
<span class="fc" id="L422">            writeBytes(bits, pubkey);</span>
<span class="fc" id="L423">            return bits.toByteArray();</span>
<span class="nc" id="L424">        } catch (IOException e) {</span>
<span class="nc" id="L425">            throw new RuntimeException(e);</span>
        }
    }

    public static byte[] createInputScript(byte[] signature) {
        try {
            // TODO: Do this by creating a Script *first* then having the script reassemble itself into bytes.
<span class="fc" id="L432">            ByteArrayOutputStream bits = new UnsafeByteArrayOutputStream(signature.length + 2);</span>
<span class="fc" id="L433">            writeBytes(bits, signature);</span>
<span class="fc" id="L434">            return bits.toByteArray();</span>
<span class="nc" id="L435">        } catch (IOException e) {</span>
<span class="nc" id="L436">            throw new RuntimeException(e);</span>
        }
    }

    /**
     * Creates an incomplete scriptSig that, once filled with signatures, can redeem output containing this scriptPubKey.
     * Instead of the signatures resulting script has OP_0.
     * Having incomplete input script allows to pass around partially signed tx.
     * It is expected that this program later on will be updated with proper signatures.
     */
    public Script createEmptyInputScript(@Nullable ECKey key, @Nullable Script redeemScript) {
<span class="fc bfc" id="L447" title="All 2 branches covered.">        if (isSentToAddress()) {</span>
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">            checkArgument(key != null, &quot;Key required to create pay-to-address input script&quot;);</span>
<span class="fc" id="L449">            return ScriptBuilder.createInputScript(null, key);</span>
<span class="fc bfc" id="L450" title="All 2 branches covered.">        } else if (isSentToRawPubKey()) {</span>
<span class="fc" id="L451">            return ScriptBuilder.createInputScript(null);</span>
<span class="pc bpc" id="L452" title="1 of 2 branches missed.">        } else if (isPayToScriptHash()) {</span>
<span class="pc bpc" id="L453" title="1 of 2 branches missed.">            checkArgument(redeemScript != null, &quot;Redeem script required to create P2SH input script&quot;);</span>
<span class="fc" id="L454">            return ScriptBuilder.createP2SHMultiSigInputScript(null, redeemScript);</span>
        } else {
<span class="nc" id="L456">            throw new ScriptException(&quot;Do not understand script type: &quot; + this);</span>
        }
    }

    /**
     * Returns a copy of the given scriptSig with the signature inserted in the given position.
     */
    public Script getScriptSigWithSignature(Script scriptSig, byte[] sigBytes, int index) {
<span class="fc" id="L464">        int sigsPrefixCount = 0;</span>
<span class="fc" id="L465">        int sigsSuffixCount = 0;</span>
<span class="fc bfc" id="L466" title="All 2 branches covered.">        if (isPayToScriptHash()) {</span>
<span class="fc" id="L467">            sigsPrefixCount = 1; // OP_0 &lt;sig&gt;* &lt;redeemScript&gt;</span>
<span class="fc" id="L468">            sigsSuffixCount = 1;</span>
<span class="pc bpc" id="L469" title="1 of 2 branches missed.">        } else if (isSentToMultiSig()) {</span>
<span class="nc" id="L470">            sigsPrefixCount = 1; // OP_0 &lt;sig&gt;*</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">        } else if (isSentToAddress()) {</span>
<span class="fc" id="L472">            sigsSuffixCount = 1; // &lt;sig&gt; &lt;pubkey&gt;</span>
        }
<span class="fc" id="L474">        return ScriptBuilder.updateScriptWithSignature(scriptSig, sigBytes, index, sigsPrefixCount, sigsSuffixCount);</span>
    }


    /**
     * Returns the index where a signature by the key should be inserted.  Only applicable to
     * a P2SH scriptSig.
     */
    public int getSigInsertionIndex(Sha256Hash hash, ECKey signingKey) {
        // Iterate over existing signatures, skipping the initial OP_0, the final redeem script
        // and any placeholder OP_0 sigs.
<span class="fc" id="L485">        List&lt;ScriptChunk&gt; existingChunks = chunks.subList(1, chunks.size() - 1);</span>
<span class="fc" id="L486">        ScriptChunk redeemScriptChunk = chunks.get(chunks.size() - 1);</span>
<span class="fc" id="L487">        checkNotNull(redeemScriptChunk.data);</span>
<span class="fc" id="L488">        Script redeemScript = new Script(redeemScriptChunk.data);</span>

<span class="fc" id="L490">        int sigCount = 0;</span>
<span class="fc" id="L491">        int myIndex = redeemScript.findKeyInRedeem(signingKey);</span>
<span class="fc bfc" id="L492" title="All 2 branches covered.">        for (ScriptChunk chunk : existingChunks) {</span>
<span class="fc bfc" id="L493" title="All 2 branches covered.">            if (chunk.opcode == OP_0) {</span>
                // OP_0, skip
            } else {
<span class="fc" id="L496">                checkNotNull(chunk.data);</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">                if (myIndex &lt; redeemScript.findSigInRedeem(chunk.data, hash))</span>
<span class="fc" id="L498">                    return sigCount;</span>
<span class="fc" id="L499">                sigCount++;</span>
            }
<span class="fc" id="L501">        }</span>
<span class="fc" id="L502">        return sigCount;</span>
    }

    private int findKeyInRedeem(ECKey key) {
<span class="fc" id="L506">        checkArgument(chunks.get(0).isOpCode()); // P2SH scriptSig</span>
<span class="fc" id="L507">        int numKeys = Script.decodeFromOpN(chunks.get(chunks.size() - 2).opcode);</span>
<span class="pc bpc" id="L508" title="1 of 2 branches missed.">        for (int i = 0 ; i &lt; numKeys ; i++) {</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">            if (Arrays.equals(chunks.get(1 + i).data, key.getPubKey())) {</span>
<span class="fc" id="L510">                return i;</span>
            }
        }

<span class="nc" id="L514">        throw new IllegalStateException(&quot;Could not find matching key &quot; + key.toString() + &quot; in script &quot; + this);</span>
    }

    /**
     * Returns a list of the keys required by this script, assuming a multi-sig script.
     *
     * @throws ScriptException if the script type is not understood or is pay to address or is P2SH (run this method on the &quot;Redeem script&quot; instead).
     */
    public List&lt;ECKey&gt; getPubKeys() {
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">        if (!isSentToMultiSig())</span>
<span class="nc" id="L524">            throw new ScriptException(&quot;Only usable for multisig scripts.&quot;);</span>

<span class="fc" id="L526">        ArrayList&lt;ECKey&gt; result = Lists.newArrayList();</span>
<span class="fc" id="L527">        int numKeys = Script.decodeFromOpN(chunks.get(chunks.size() - 2).opcode);</span>
<span class="fc bfc" id="L528" title="All 2 branches covered.">        for (int i = 0 ; i &lt; numKeys ; i++)</span>
<span class="fc" id="L529">            result.add(ECKey.fromPublicOnly(chunks.get(1 + i).data));</span>
<span class="fc" id="L530">        return result;</span>
    }

    private int findSigInRedeem(byte[] signatureBytes, Sha256Hash hash) {
<span class="fc" id="L534">        checkArgument(chunks.get(0).isOpCode()); // P2SH scriptSig</span>
<span class="fc" id="L535">        int numKeys = Script.decodeFromOpN(chunks.get(chunks.size() - 2).opcode);</span>
<span class="fc" id="L536">        TransactionSignature signature = TransactionSignature.decodeFromFLO(signatureBytes, true);</span>
<span class="pc bpc" id="L537" title="1 of 2 branches missed.">        for (int i = 0 ; i &lt; numKeys ; i++) {</span>
<span class="fc bfc" id="L538" title="All 2 branches covered.">            if (ECKey.fromPublicOnly(chunks.get(i + 1).data).verify(hash, signature)) {</span>
<span class="fc" id="L539">                return i;</span>
            }
        }

<span class="nc" id="L543">        throw new IllegalStateException(&quot;Could not find matching key for signature on &quot; + hash.toString() + &quot; sig &quot; + Utils.HEX.encode(signatureBytes));</span>
    }



    ////////////////////// Interface used during verification of transactions/blocks ////////////////////////////////

    private static int getSigOpCount(List&lt;ScriptChunk&gt; chunks, boolean accurate) throws ScriptException {
<span class="fc" id="L551">        int sigOps = 0;</span>
<span class="fc" id="L552">        int lastOpCode = OP_INVALIDOPCODE;</span>
<span class="fc bfc" id="L553" title="All 2 branches covered.">        for (ScriptChunk chunk : chunks) {</span>
<span class="fc bfc" id="L554" title="All 2 branches covered.">            if (chunk.isOpCode()) {</span>
<span class="fc bfc" id="L555" title="All 3 branches covered.">                switch (chunk.opcode) {</span>
                case OP_CHECKSIG:
                case OP_CHECKSIGVERIFY:
<span class="fc" id="L558">                    sigOps++;</span>
<span class="fc" id="L559">                    break;</span>
                case OP_CHECKMULTISIG:
                case OP_CHECKMULTISIGVERIFY:
<span class="pc bpc" id="L562" title="5 of 6 branches missed.">                    if (accurate &amp;&amp; lastOpCode &gt;= OP_1 &amp;&amp; lastOpCode &lt;= OP_16)</span>
<span class="nc" id="L563">                        sigOps += decodeFromOpN(lastOpCode);</span>
                    else
<span class="fc" id="L565">                        sigOps += 20;</span>
<span class="fc" id="L566">                    break;</span>
                default:
                    break;
                }
<span class="fc" id="L570">                lastOpCode = chunk.opcode;</span>
            }
<span class="fc" id="L572">        }</span>
<span class="fc" id="L573">        return sigOps;</span>
    }

    static int decodeFromOpN(int opcode) {
<span class="pc bpc" id="L577" title="3 of 8 branches missed.">        checkArgument((opcode == OP_0 || opcode == OP_1NEGATE) || (opcode &gt;= OP_1 &amp;&amp; opcode &lt;= OP_16), &quot;decodeFromOpN called on non OP_N opcode&quot;);</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">        if (opcode == OP_0)</span>
<span class="fc" id="L579">            return 0;</span>
<span class="pc bpc" id="L580" title="1 of 2 branches missed.">        else if (opcode == OP_1NEGATE)</span>
<span class="nc" id="L581">            return -1;</span>
        else
<span class="fc" id="L583">            return opcode + 1 - OP_1;</span>
    }

    static int encodeToOpN(int value) {
<span class="pc bpc" id="L587" title="2 of 4 branches missed.">        checkArgument(value &gt;= -1 &amp;&amp; value &lt;= 16, &quot;encodeToOpN called for &quot; + value + &quot; which we cannot encode in an opcode.&quot;);</span>
<span class="fc bfc" id="L588" title="All 2 branches covered.">        if (value == 0)</span>
<span class="fc" id="L589">            return OP_0;</span>
<span class="fc bfc" id="L590" title="All 2 branches covered.">        else if (value == -1)</span>
<span class="fc" id="L591">            return OP_1NEGATE;</span>
        else
<span class="fc" id="L593">            return value - 1 + OP_1;</span>
    }

    /**
     * Gets the count of regular SigOps in the script program (counting multisig ops as 20)
     */
    public static int getSigOpCount(byte[] program) throws ScriptException {
<span class="fc" id="L600">        Script script = new Script();</span>
        try {
<span class="fc" id="L602">            script.parse(program);</span>
<span class="fc" id="L603">        } catch (ScriptException e) {</span>
            // Ignore errors and count up to the parse-able length
<span class="fc" id="L605">        }</span>
<span class="fc" id="L606">        return getSigOpCount(script.chunks, false);</span>
    }
    
    /**
     * Gets the count of P2SH Sig Ops in the Script scriptSig
     */
    public static long getP2SHSigOpCount(byte[] scriptSig) throws ScriptException {
<span class="fc" id="L613">        Script script = new Script();</span>
        try {
<span class="fc" id="L615">            script.parse(scriptSig);</span>
<span class="nc" id="L616">        } catch (ScriptException e) {</span>
            // Ignore errors and count up to the parse-able length
<span class="fc" id="L618">        }</span>
<span class="pc bpc" id="L619" title="1 of 2 branches missed.">        for (int i = script.chunks.size() - 1; i &gt;= 0; i--)</span>
<span class="pc bpc" id="L620" title="1 of 2 branches missed.">            if (!script.chunks.get(i).isOpCode()) {</span>
<span class="fc" id="L621">                Script subScript =  new Script();</span>
<span class="fc" id="L622">                subScript.parse(script.chunks.get(i).data);</span>
<span class="fc" id="L623">                return getSigOpCount(subScript.chunks, true);</span>
            }
<span class="nc" id="L625">        return 0;</span>
    }

    /**
     * Returns number of signatures required to satisfy this script.
     */
    public int getNumberOfSignaturesRequiredToSpend() {
<span class="pc bpc" id="L632" title="1 of 2 branches missed.">        if (isSentToMultiSig()) {</span>
            // for N of M CHECKMULTISIG script we will need N signatures to spend
<span class="fc" id="L634">            ScriptChunk nChunk = chunks.get(0);</span>
<span class="fc" id="L635">            return Script.decodeFromOpN(nChunk.opcode);</span>
<span class="nc bnc" id="L636" title="All 4 branches missed.">        } else if (isSentToAddress() || isSentToRawPubKey()) {</span>
            // pay-to-address and pay-to-pubkey require single sig
<span class="nc" id="L638">            return 1;</span>
<span class="nc bnc" id="L639" title="All 2 branches missed.">        } else if (isPayToScriptHash()) {</span>
<span class="nc" id="L640">            throw new IllegalStateException(&quot;For P2SH number of signatures depends on redeem script&quot;);</span>
        } else {
<span class="nc" id="L642">            throw new IllegalStateException(&quot;Unsupported script type&quot;);</span>
        }
    }

    /**
     * Returns number of bytes required to spend this script. It accepts optional ECKey and redeemScript that may
     * be required for certain types of script to estimate target size.
     */
    public int getNumberOfBytesRequiredToSpend(@Nullable ECKey pubKey, @Nullable Script redeemScript) {
<span class="fc bfc" id="L651" title="All 2 branches covered.">        if (isPayToScriptHash()) {</span>
            // scriptSig: &lt;sig&gt; [sig] [sig...] &lt;redeemscript&gt;
<span class="pc bpc" id="L653" title="1 of 2 branches missed.">            checkArgument(redeemScript != null, &quot;P2SH script requires redeemScript to be spent&quot;);</span>
<span class="fc" id="L654">            return redeemScript.getNumberOfSignaturesRequiredToSpend() * SIG_SIZE + redeemScript.getProgram().length;</span>
<span class="pc bpc" id="L655" title="1 of 2 branches missed.">        } else if (isSentToMultiSig()) {</span>
            // scriptSig: OP_0 &lt;sig&gt; [sig] [sig...]
<span class="nc" id="L657">            return getNumberOfSignaturesRequiredToSpend() * SIG_SIZE + 1;</span>
<span class="fc bfc" id="L658" title="All 2 branches covered.">        } else if (isSentToRawPubKey()) {</span>
            // scriptSig: &lt;sig&gt;
<span class="fc" id="L660">            return SIG_SIZE;</span>
<span class="pc bpc" id="L661" title="1 of 2 branches missed.">        } else if (isSentToAddress()) {</span>
            // scriptSig: &lt;sig&gt; &lt;pubkey&gt;
<span class="fc" id="L663">            int uncompressedPubKeySize = 65;</span>
<span class="pc bpc" id="L664" title="1 of 2 branches missed.">            return SIG_SIZE + (pubKey != null ? pubKey.getPubKey().length : uncompressedPubKeySize);</span>
        } else {
<span class="nc" id="L666">            throw new IllegalStateException(&quot;Unsupported script type&quot;);</span>
        }
    }

    /**
     * &lt;p&gt;Whether or not this is a scriptPubKey representing a pay-to-script-hash output. In such outputs, the logic that
     * controls reclamation is not actually in the output at all. Instead there's just a hash, and it's up to the
     * spending input to provide a program matching that hash. This rule is &quot;soft enforced&quot; by the network as it does
     * not exist in FLO Core. It means blocks containing P2SH transactions that don't match
     * correctly are considered valid, but won't be mined upon, so they'll be rapidly re-orgd out of the chain. This
     * logic is defined by &lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki&quot;&gt;BIP 16&lt;/a&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;bitcoinj does not support creation of P2SH transactions today. The goal of P2SH is to allow short addresses
     * even for complex scripts (eg, multi-sig outputs) so they are convenient to work with in things like QRcodes or
     * with copy/paste, and also to minimize the size of the unspent output set (which improves performance of the
     * FLO system).&lt;/p&gt;
     */
    public boolean isPayToScriptHash() {
        // We have to check against the serialized form because BIP16 defines a P2SH output using an exact byte
        // template, not the logical program structure. Thus you can have two programs that look identical when
        // printed out but one is a P2SH script and the other isn't! :(
<span class="fc" id="L687">        byte[] program = getProgram();</span>
<span class="pc bpc" id="L688" title="2 of 8 branches missed.">        return program.length == 23 &amp;&amp;</span>
               (program[0] &amp; 0xff) == OP_HASH160 &amp;&amp;
               (program[1] &amp; 0xff) == 0x14 &amp;&amp;
               (program[22] &amp; 0xff) == OP_EQUAL;
    }

    /**
     * Returns whether this script matches the format used for multisig outputs: [n] [keys...] [m] CHECKMULTISIG
     */
    public boolean isSentToMultiSig() {
<span class="fc bfc" id="L698" title="All 2 branches covered.">        if (chunks.size() &lt; 4) return false;</span>
<span class="fc" id="L699">        ScriptChunk chunk = chunks.get(chunks.size() - 1);</span>
        // Must end in OP_CHECKMULTISIG[VERIFY].
<span class="pc bpc" id="L701" title="1 of 2 branches missed.">        if (!chunk.isOpCode()) return false;</span>
<span class="pc bpc" id="L702" title="1 of 4 branches missed.">        if (!(chunk.equalsOpCode(OP_CHECKMULTISIG) || chunk.equalsOpCode(OP_CHECKMULTISIGVERIFY))) return false;</span>
        try {
            // Second to last chunk must be an OP_N opcode and there should be that many data chunks (keys).
<span class="fc" id="L705">            ScriptChunk m = chunks.get(chunks.size() - 2);</span>
<span class="pc bpc" id="L706" title="1 of 2 branches missed.">            if (!m.isOpCode()) return false;</span>
<span class="fc" id="L707">            int numKeys = decodeFromOpN(m.opcode);</span>
<span class="pc bpc" id="L708" title="2 of 4 branches missed.">            if (numKeys &lt; 1 || chunks.size() != 3 + numKeys) return false;</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">            for (int i = 1; i &lt; chunks.size() - 2; i++) {</span>
<span class="pc bpc" id="L710" title="1 of 2 branches missed.">                if (chunks.get(i).isOpCode()) return false;</span>
            }
            // First chunk must be an OP_N opcode too.
<span class="pc bpc" id="L713" title="1 of 2 branches missed.">            if (decodeFromOpN(chunks.get(0).opcode) &lt; 1) return false;</span>
<span class="nc" id="L714">        } catch (IllegalArgumentException e) { // thrown by decodeFromOpN()</span>
<span class="nc" id="L715">            return false;   // Not an OP_N opcode.</span>
<span class="fc" id="L716">        }</span>
<span class="fc" id="L717">        return true;</span>
    }

    public boolean isSentToCLTVPaymentChannel() {
<span class="pc bpc" id="L721" title="1 of 2 branches missed.">        if (chunks.size() != 10) return false;</span>
        // Check that opcodes match the pre-determined format.
<span class="pc bpc" id="L723" title="1 of 2 branches missed.">        if (!chunks.get(0).equalsOpCode(OP_IF)) return false;</span>
        // chunk[1] = recipient pubkey
<span class="pc bpc" id="L725" title="1 of 2 branches missed.">        if (!chunks.get(2).equalsOpCode(OP_CHECKSIGVERIFY)) return false;</span>
<span class="pc bpc" id="L726" title="1 of 2 branches missed.">        if (!chunks.get(3).equalsOpCode(OP_ELSE)) return false;</span>
        // chunk[4] = locktime
<span class="pc bpc" id="L728" title="1 of 2 branches missed.">        if (!chunks.get(5).equalsOpCode(OP_CHECKLOCKTIMEVERIFY)) return false;</span>
<span class="pc bpc" id="L729" title="1 of 2 branches missed.">        if (!chunks.get(6).equalsOpCode(OP_DROP)) return false;</span>
<span class="pc bpc" id="L730" title="1 of 2 branches missed.">        if (!chunks.get(7).equalsOpCode(OP_ENDIF)) return false;</span>
        // chunk[8] = sender pubkey
<span class="pc bpc" id="L732" title="1 of 2 branches missed.">        if (!chunks.get(9).equalsOpCode(OP_CHECKSIG)) return false;</span>
<span class="fc" id="L733">        return true;</span>
    }

    private static boolean equalsRange(byte[] a, int start, byte[] b) {
<span class="fc bfc" id="L737" title="All 2 branches covered.">        if (start + b.length &gt; a.length)</span>
<span class="fc" id="L738">            return false;</span>
<span class="fc bfc" id="L739" title="All 2 branches covered.">        for (int i = 0; i &lt; b.length; i++)</span>
<span class="fc bfc" id="L740" title="All 2 branches covered.">            if (a[i + start] != b[i])</span>
<span class="fc" id="L741">                return false;</span>
<span class="fc" id="L742">        return true;</span>
    }
    
    /**
     * Returns the script bytes of inputScript with all instances of the specified script object removed
     */
    public static byte[] removeAllInstancesOf(byte[] inputScript, byte[] chunkToRemove) {
        // We usually don't end up removing anything
<span class="fc" id="L750">        UnsafeByteArrayOutputStream bos = new UnsafeByteArrayOutputStream(inputScript.length);</span>

<span class="fc" id="L752">        int cursor = 0;</span>
<span class="fc bfc" id="L753" title="All 2 branches covered.">        while (cursor &lt; inputScript.length) {</span>
<span class="fc" id="L754">            boolean skip = equalsRange(inputScript, cursor, chunkToRemove);</span>
            
<span class="fc" id="L756">            int opcode = inputScript[cursor++] &amp; 0xFF;</span>
<span class="fc" id="L757">            int additionalBytes = 0;</span>
<span class="pc bpc" id="L758" title="1 of 4 branches missed.">            if (opcode &gt;= 0 &amp;&amp; opcode &lt; OP_PUSHDATA1) {</span>
<span class="fc" id="L759">                additionalBytes = opcode;</span>
<span class="fc bfc" id="L760" title="All 2 branches covered.">            } else if (opcode == OP_PUSHDATA1) {</span>
<span class="fc" id="L761">                additionalBytes = (0xFF &amp; inputScript[cursor]) + 1;</span>
<span class="pc bpc" id="L762" title="1 of 2 branches missed.">            } else if (opcode == OP_PUSHDATA2) {</span>
<span class="nc" id="L763">                additionalBytes = ((0xFF &amp; inputScript[cursor]) |</span>
                                  ((0xFF &amp; inputScript[cursor+1]) &lt;&lt; 8)) + 2;
<span class="pc bpc" id="L765" title="1 of 2 branches missed.">            } else if (opcode == OP_PUSHDATA4) {</span>
<span class="nc" id="L766">                additionalBytes = ((0xFF &amp; inputScript[cursor]) |</span>
                                  ((0xFF &amp; inputScript[cursor+1]) &lt;&lt; 8) |
                                  ((0xFF &amp; inputScript[cursor+1]) &lt;&lt; 16) |
                                  ((0xFF &amp; inputScript[cursor+1]) &lt;&lt; 24)) + 4;
            }
<span class="fc bfc" id="L771" title="All 2 branches covered.">            if (!skip) {</span>
                try {
<span class="fc" id="L773">                    bos.write(opcode);</span>
<span class="fc" id="L774">                    bos.write(Arrays.copyOfRange(inputScript, cursor, cursor + additionalBytes));</span>
<span class="nc" id="L775">                } catch (IOException e) {</span>
<span class="nc" id="L776">                    throw new RuntimeException(e);</span>
<span class="fc" id="L777">                }</span>
            }
<span class="fc" id="L779">            cursor += additionalBytes;</span>
<span class="fc" id="L780">        }</span>
<span class="fc" id="L781">        return bos.toByteArray();</span>
    }
    
    /**
     * Returns the script bytes of inputScript with all instances of the given op code removed
     */
    public static byte[] removeAllInstancesOfOp(byte[] inputScript, int opCode) {
<span class="fc" id="L788">        return removeAllInstancesOf(inputScript, new byte[] {(byte)opCode});</span>
    }
    
    ////////////////////// Script verification and helpers ////////////////////////////////
    
    private static boolean castToBool(byte[] data) {
<span class="fc bfc" id="L794" title="All 2 branches covered.">        for (int i = 0; i &lt; data.length; i++)</span>
        {
            // &quot;Can be negative zero&quot; - FLO Core (see OpenSSL's BN_bn2mpi)
<span class="fc bfc" id="L797" title="All 2 branches covered.">            if (data[i] != 0)</span>
<span class="fc bfc" id="L798" title="All 4 branches covered.">                return !(i == data.length - 1 &amp;&amp; (data[i] &amp; 0xFF) == 0x80);</span>
        }
<span class="fc" id="L800">        return false;</span>
    }
    
    /**
     * Cast a script chunk to a BigInteger.
     *
     * @see #castToBigInteger(byte[], int, boolean) for values with different maximum
     * sizes.
     * @throws ScriptException if the chunk is longer than 4 bytes.
     */
    private static BigInteger castToBigInteger(byte[] chunk) throws ScriptException {
<span class="fc bfc" id="L811" title="All 2 branches covered.">        if (chunk.length &gt; 4)</span>
<span class="fc" id="L812">            throw new ScriptException(&quot;Script attempted to use an integer larger than 4 bytes&quot;);</span>
<span class="fc" id="L813">        return Utils.decodeMPI(Utils.reverseBytes(chunk), false);</span>
    }

    /**
     * Cast a script chunk to a BigInteger. Normally you would want
     * {@link #castToBigInteger(byte[], boolean)} instead, this is only for cases where
     * the normal maximum length does not apply (i.e. CHECKLOCKTIMEVERIFY).
     *
     * @param maxLength the maximum length in bytes.
     * @throws ScriptException if the chunk is longer than the specified maximum.
     */
    private static BigInteger castToBigInteger(final byte[] chunk, final int maxLength) throws ScriptException {
<span class="fc bfc" id="L825" title="All 2 branches covered.">        if (chunk.length &gt; maxLength)</span>
<span class="fc" id="L826">            throw new ScriptException(&quot;Script attempted to use an integer larger than &quot;</span>
                + maxLength + &quot; bytes&quot;);
<span class="fc" id="L828">        return Utils.decodeMPI(Utils.reverseBytes(chunk), false);</span>
    }

    public boolean isOpReturn() {
<span class="pc bpc" id="L832" title="1 of 4 branches missed.">        return chunks.size() &gt; 0 &amp;&amp; chunks.get(0).equalsOpCode(OP_RETURN);</span>
    }

    /**
     * Exposes the script interpreter. Normally you should not use this directly, instead use
     * {@link org.bitcoinj.core.TransactionInput#verify(org.bitcoinj.core.TransactionOutput)} or
     * {@link org.bitcoinj.script.Script#correctlySpends(org.bitcoinj.core.Transaction, long, Script)}. This method
     * is useful if you need more precise control or access to the final state of the stack. This interface is very
     * likely to change in future.
     *
     * @deprecated Use {@link #executeScript(org.bitcoinj.core.Transaction, long, org.bitcoinj.script.Script, java.util.LinkedList, java.util.Set)}
     * instead.
     */
    @Deprecated
    public static void executeScript(@Nullable Transaction txContainingThis, long index,
                                     Script script, LinkedList&lt;byte[]&gt; stack, boolean enforceNullDummy) throws ScriptException {
<span class="nc bnc" id="L848" title="All 2 branches missed.">        final EnumSet&lt;VerifyFlag&gt; flags = enforceNullDummy</span>
<span class="nc" id="L849">            ? EnumSet.of(VerifyFlag.NULLDUMMY)</span>
<span class="nc" id="L850">            : EnumSet.noneOf(VerifyFlag.class);</span>

<span class="nc" id="L852">        executeScript(txContainingThis, index, script, stack, flags);</span>
<span class="nc" id="L853">    }</span>

    /**
     * Exposes the script interpreter. Normally you should not use this directly, instead use
     * {@link org.bitcoinj.core.TransactionInput#verify(org.bitcoinj.core.TransactionOutput)} or
     * {@link org.bitcoinj.script.Script#correctlySpends(org.bitcoinj.core.Transaction, long, Script)}. This method
     * is useful if you need more precise control or access to the final state of the stack. This interface is very
     * likely to change in future.
     */
    public static void executeScript(@Nullable Transaction txContainingThis, long index,
                                     Script script, LinkedList&lt;byte[]&gt; stack, Set&lt;VerifyFlag&gt; verifyFlags) throws ScriptException {
<span class="fc" id="L864">        int opCount = 0;</span>
<span class="fc" id="L865">        int lastCodeSepLocation = 0;</span>
        
<span class="fc" id="L867">        LinkedList&lt;byte[]&gt; altstack = new LinkedList&lt;byte[]&gt;();</span>
<span class="fc" id="L868">        LinkedList&lt;Boolean&gt; ifStack = new LinkedList&lt;Boolean&gt;();</span>
        
<span class="fc bfc" id="L870" title="All 2 branches covered.">        for (ScriptChunk chunk : script.chunks) {</span>
<span class="fc bfc" id="L871" title="All 2 branches covered.">            boolean shouldExecute = !ifStack.contains(false);</span>

<span class="fc bfc" id="L873" title="All 2 branches covered.">            if (chunk.opcode == OP_0) {</span>
<span class="fc bfc" id="L874" title="All 2 branches covered.">                if (!shouldExecute)</span>
<span class="fc" id="L875">                    continue;</span>

<span class="fc" id="L877">                stack.add(new byte[] {});</span>
<span class="fc bfc" id="L878" title="All 2 branches covered.">            } else if (!chunk.isOpCode()) {</span>
<span class="fc bfc" id="L879" title="All 2 branches covered.">                if (chunk.data.length &gt; MAX_SCRIPT_ELEMENT_SIZE)</span>
<span class="fc" id="L880">                    throw new ScriptException(&quot;Attempted to push a data string larger than 520 bytes&quot;);</span>
                
<span class="fc bfc" id="L882" title="All 2 branches covered.">                if (!shouldExecute)</span>
<span class="fc" id="L883">                    continue;</span>
                
<span class="fc" id="L885">                stack.add(chunk.data);</span>
            } else {
<span class="fc" id="L887">                int opcode = chunk.opcode;</span>
<span class="fc bfc" id="L888" title="All 2 branches covered.">                if (opcode &gt; OP_16) {</span>
<span class="fc" id="L889">                    opCount++;</span>
<span class="fc bfc" id="L890" title="All 2 branches covered.">                    if (opCount &gt; 201)</span>
<span class="fc" id="L891">                        throw new ScriptException(&quot;More script operations than is allowed&quot;);</span>
                }
                
<span class="fc bfc" id="L894" title="All 4 branches covered.">                if (opcode == OP_VERIF || opcode == OP_VERNOTIF)</span>
<span class="fc" id="L895">                    throw new ScriptException(&quot;Script included OP_VERIF or OP_VERNOTIF&quot;);</span>
                
<span class="fc bfc" id="L897" title="All 30 branches covered.">                if (opcode == OP_CAT || opcode == OP_SUBSTR || opcode == OP_LEFT || opcode == OP_RIGHT ||</span>
                    opcode == OP_INVERT || opcode == OP_AND || opcode == OP_OR || opcode == OP_XOR ||
                    opcode == OP_2MUL || opcode == OP_2DIV || opcode == OP_MUL || opcode == OP_DIV ||
                    opcode == OP_MOD || opcode == OP_LSHIFT || opcode == OP_RSHIFT)
<span class="fc" id="L901">                    throw new ScriptException(&quot;Script included a disabled Script Op.&quot;);</span>
                
<span class="fc bfc" id="L903" title="All 5 branches covered.">                switch (opcode) {</span>
                case OP_IF:
<span class="fc bfc" id="L905" title="All 2 branches covered.">                    if (!shouldExecute) {</span>
<span class="fc" id="L906">                        ifStack.add(false);</span>
<span class="fc" id="L907">                        continue;</span>
                    }
<span class="fc bfc" id="L909" title="All 2 branches covered.">                    if (stack.size() &lt; 1)</span>
<span class="fc" id="L910">                        throw new ScriptException(&quot;Attempted OP_IF on an empty stack&quot;);</span>
<span class="fc" id="L911">                    ifStack.add(castToBool(stack.pollLast()));</span>
<span class="fc" id="L912">                    continue;</span>
                case OP_NOTIF:
<span class="fc bfc" id="L914" title="All 2 branches covered.">                    if (!shouldExecute) {</span>
<span class="fc" id="L915">                        ifStack.add(false);</span>
<span class="fc" id="L916">                        continue;</span>
                    }
<span class="fc bfc" id="L918" title="All 2 branches covered.">                    if (stack.size() &lt; 1)</span>
<span class="fc" id="L919">                        throw new ScriptException(&quot;Attempted OP_NOTIF on an empty stack&quot;);</span>
<span class="fc bfc" id="L920" title="All 2 branches covered.">                    ifStack.add(!castToBool(stack.pollLast()));</span>
<span class="fc" id="L921">                    continue;</span>
                case OP_ELSE:
<span class="fc bfc" id="L923" title="All 2 branches covered.">                    if (ifStack.isEmpty())</span>
<span class="fc" id="L924">                        throw new ScriptException(&quot;Attempted OP_ELSE without OP_IF/NOTIF&quot;);</span>
<span class="fc bfc" id="L925" title="All 2 branches covered.">                    ifStack.add(!ifStack.pollLast());</span>
<span class="fc" id="L926">                    continue;</span>
                case OP_ENDIF:
<span class="fc bfc" id="L928" title="All 2 branches covered.">                    if (ifStack.isEmpty())</span>
<span class="fc" id="L929">                        throw new ScriptException(&quot;Attempted OP_ENDIF without OP_IF/NOTIF&quot;);</span>
<span class="fc" id="L930">                    ifStack.pollLast();</span>
<span class="fc" id="L931">                    continue;</span>
                }
                
<span class="fc bfc" id="L934" title="All 2 branches covered.">                if (!shouldExecute)</span>
<span class="fc" id="L935">                    continue;</span>
                
<span class="pc bpc" id="L937" title="4 of 44 branches missed.">                switch(opcode) {</span>
                // OP_0 is no opcode
                case OP_1NEGATE:
<span class="fc" id="L940">                    stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ONE.negate(), false)));</span>
<span class="fc" id="L941">                    break;</span>
                case OP_1:
                case OP_2:
                case OP_3:
                case OP_4:
                case OP_5:
                case OP_6:
                case OP_7:
                case OP_8:
                case OP_9:
                case OP_10:
                case OP_11:
                case OP_12:
                case OP_13:
                case OP_14:
                case OP_15:
                case OP_16:
<span class="fc" id="L958">                    stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(decodeFromOpN(opcode)), false)));</span>
<span class="fc" id="L959">                    break;</span>
                case OP_NOP:
<span class="fc" id="L961">                    break;</span>
                case OP_VERIFY:
<span class="fc bfc" id="L963" title="All 2 branches covered.">                    if (stack.size() &lt; 1)</span>
<span class="fc" id="L964">                        throw new ScriptException(&quot;Attempted OP_VERIFY on an empty stack&quot;);</span>
<span class="fc bfc" id="L965" title="All 2 branches covered.">                    if (!castToBool(stack.pollLast()))</span>
<span class="fc" id="L966">                        throw new ScriptException(&quot;OP_VERIFY failed&quot;);</span>
                    break;
                case OP_RETURN:
<span class="fc" id="L969">                    throw new ScriptException(&quot;Script called OP_RETURN&quot;);</span>
                case OP_TOALTSTACK:
<span class="fc bfc" id="L971" title="All 2 branches covered.">                    if (stack.size() &lt; 1)</span>
<span class="fc" id="L972">                        throw new ScriptException(&quot;Attempted OP_TOALTSTACK on an empty stack&quot;);</span>
<span class="fc" id="L973">                    altstack.add(stack.pollLast());</span>
<span class="fc" id="L974">                    break;</span>
                case OP_FROMALTSTACK:
<span class="fc bfc" id="L976" title="All 2 branches covered.">                    if (altstack.size() &lt; 1)</span>
<span class="fc" id="L977">                        throw new ScriptException(&quot;Attempted OP_FROMALTSTACK on an empty altstack&quot;);</span>
<span class="fc" id="L978">                    stack.add(altstack.pollLast());</span>
<span class="fc" id="L979">                    break;</span>
                case OP_2DROP:
<span class="fc bfc" id="L981" title="All 2 branches covered.">                    if (stack.size() &lt; 2)</span>
<span class="fc" id="L982">                        throw new ScriptException(&quot;Attempted OP_2DROP on a stack with size &lt; 2&quot;);</span>
<span class="fc" id="L983">                    stack.pollLast();</span>
<span class="fc" id="L984">                    stack.pollLast();</span>
<span class="fc" id="L985">                    break;</span>
                case OP_2DUP:
<span class="fc bfc" id="L987" title="All 2 branches covered.">                    if (stack.size() &lt; 2)</span>
<span class="fc" id="L988">                        throw new ScriptException(&quot;Attempted OP_2DUP on a stack with size &lt; 2&quot;);</span>
<span class="fc" id="L989">                    Iterator&lt;byte[]&gt; it2DUP = stack.descendingIterator();</span>
<span class="fc" id="L990">                    byte[] OP2DUPtmpChunk2 = it2DUP.next();</span>
<span class="fc" id="L991">                    stack.add(it2DUP.next());</span>
<span class="fc" id="L992">                    stack.add(OP2DUPtmpChunk2);</span>
<span class="fc" id="L993">                    break;</span>
                case OP_3DUP:
<span class="fc bfc" id="L995" title="All 2 branches covered.">                    if (stack.size() &lt; 3)</span>
<span class="fc" id="L996">                        throw new ScriptException(&quot;Attempted OP_3DUP on a stack with size &lt; 3&quot;);</span>
<span class="fc" id="L997">                    Iterator&lt;byte[]&gt; it3DUP = stack.descendingIterator();</span>
<span class="fc" id="L998">                    byte[] OP3DUPtmpChunk3 = it3DUP.next();</span>
<span class="fc" id="L999">                    byte[] OP3DUPtmpChunk2 = it3DUP.next();</span>
<span class="fc" id="L1000">                    stack.add(it3DUP.next());</span>
<span class="fc" id="L1001">                    stack.add(OP3DUPtmpChunk2);</span>
<span class="fc" id="L1002">                    stack.add(OP3DUPtmpChunk3);</span>
<span class="fc" id="L1003">                    break;</span>
                case OP_2OVER:
<span class="fc bfc" id="L1005" title="All 2 branches covered.">                    if (stack.size() &lt; 4)</span>
<span class="fc" id="L1006">                        throw new ScriptException(&quot;Attempted OP_2OVER on a stack with size &lt; 4&quot;);</span>
<span class="fc" id="L1007">                    Iterator&lt;byte[]&gt; it2OVER = stack.descendingIterator();</span>
<span class="fc" id="L1008">                    it2OVER.next();</span>
<span class="fc" id="L1009">                    it2OVER.next();</span>
<span class="fc" id="L1010">                    byte[] OP2OVERtmpChunk2 = it2OVER.next();</span>
<span class="fc" id="L1011">                    stack.add(it2OVER.next());</span>
<span class="fc" id="L1012">                    stack.add(OP2OVERtmpChunk2);</span>
<span class="fc" id="L1013">                    break;</span>
                case OP_2ROT:
<span class="fc bfc" id="L1015" title="All 2 branches covered.">                    if (stack.size() &lt; 6)</span>
<span class="fc" id="L1016">                        throw new ScriptException(&quot;Attempted OP_2ROT on a stack with size &lt; 6&quot;);</span>
<span class="fc" id="L1017">                    byte[] OP2ROTtmpChunk6 = stack.pollLast();</span>
<span class="fc" id="L1018">                    byte[] OP2ROTtmpChunk5 = stack.pollLast();</span>
<span class="fc" id="L1019">                    byte[] OP2ROTtmpChunk4 = stack.pollLast();</span>
<span class="fc" id="L1020">                    byte[] OP2ROTtmpChunk3 = stack.pollLast();</span>
<span class="fc" id="L1021">                    byte[] OP2ROTtmpChunk2 = stack.pollLast();</span>
<span class="fc" id="L1022">                    byte[] OP2ROTtmpChunk1 = stack.pollLast();</span>
<span class="fc" id="L1023">                    stack.add(OP2ROTtmpChunk3);</span>
<span class="fc" id="L1024">                    stack.add(OP2ROTtmpChunk4);</span>
<span class="fc" id="L1025">                    stack.add(OP2ROTtmpChunk5);</span>
<span class="fc" id="L1026">                    stack.add(OP2ROTtmpChunk6);</span>
<span class="fc" id="L1027">                    stack.add(OP2ROTtmpChunk1);</span>
<span class="fc" id="L1028">                    stack.add(OP2ROTtmpChunk2);</span>
<span class="fc" id="L1029">                    break;</span>
                case OP_2SWAP:
<span class="fc bfc" id="L1031" title="All 2 branches covered.">                    if (stack.size() &lt; 4)</span>
<span class="fc" id="L1032">                        throw new ScriptException(&quot;Attempted OP_2SWAP on a stack with size &lt; 4&quot;);</span>
<span class="fc" id="L1033">                    byte[] OP2SWAPtmpChunk4 = stack.pollLast();</span>
<span class="fc" id="L1034">                    byte[] OP2SWAPtmpChunk3 = stack.pollLast();</span>
<span class="fc" id="L1035">                    byte[] OP2SWAPtmpChunk2 = stack.pollLast();</span>
<span class="fc" id="L1036">                    byte[] OP2SWAPtmpChunk1 = stack.pollLast();</span>
<span class="fc" id="L1037">                    stack.add(OP2SWAPtmpChunk3);</span>
<span class="fc" id="L1038">                    stack.add(OP2SWAPtmpChunk4);</span>
<span class="fc" id="L1039">                    stack.add(OP2SWAPtmpChunk1);</span>
<span class="fc" id="L1040">                    stack.add(OP2SWAPtmpChunk2);</span>
<span class="fc" id="L1041">                    break;</span>
                case OP_IFDUP:
<span class="fc bfc" id="L1043" title="All 2 branches covered.">                    if (stack.size() &lt; 1)</span>
<span class="fc" id="L1044">                        throw new ScriptException(&quot;Attempted OP_IFDUP on an empty stack&quot;);</span>
<span class="fc bfc" id="L1045" title="All 2 branches covered.">                    if (castToBool(stack.getLast()))</span>
<span class="fc" id="L1046">                        stack.add(stack.getLast());</span>
                    break;
                case OP_DEPTH:
<span class="fc" id="L1049">                    stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(stack.size()), false)));</span>
<span class="fc" id="L1050">                    break;</span>
                case OP_DROP:
<span class="fc bfc" id="L1052" title="All 2 branches covered.">                    if (stack.size() &lt; 1)</span>
<span class="fc" id="L1053">                        throw new ScriptException(&quot;Attempted OP_DROP on an empty stack&quot;);</span>
<span class="fc" id="L1054">                    stack.pollLast();</span>
<span class="fc" id="L1055">                    break;</span>
                case OP_DUP:
<span class="fc bfc" id="L1057" title="All 2 branches covered.">                    if (stack.size() &lt; 1)</span>
<span class="fc" id="L1058">                        throw new ScriptException(&quot;Attempted OP_DUP on an empty stack&quot;);</span>
<span class="fc" id="L1059">                    stack.add(stack.getLast());</span>
<span class="fc" id="L1060">                    break;</span>
                case OP_NIP:
<span class="fc bfc" id="L1062" title="All 2 branches covered.">                    if (stack.size() &lt; 2)</span>
<span class="fc" id="L1063">                        throw new ScriptException(&quot;Attempted OP_NIP on a stack with size &lt; 2&quot;);</span>
<span class="fc" id="L1064">                    byte[] OPNIPtmpChunk = stack.pollLast();</span>
<span class="fc" id="L1065">                    stack.pollLast();</span>
<span class="fc" id="L1066">                    stack.add(OPNIPtmpChunk);</span>
<span class="fc" id="L1067">                    break;</span>
                case OP_OVER:
<span class="fc bfc" id="L1069" title="All 2 branches covered.">                    if (stack.size() &lt; 2)</span>
<span class="fc" id="L1070">                        throw new ScriptException(&quot;Attempted OP_OVER on a stack with size &lt; 2&quot;);</span>
<span class="fc" id="L1071">                    Iterator&lt;byte[]&gt; itOVER = stack.descendingIterator();</span>
<span class="fc" id="L1072">                    itOVER.next();</span>
<span class="fc" id="L1073">                    stack.add(itOVER.next());</span>
<span class="fc" id="L1074">                    break;</span>
                case OP_PICK:
                case OP_ROLL:
<span class="pc bpc" id="L1077" title="1 of 2 branches missed.">                    if (stack.size() &lt; 1)</span>
<span class="nc" id="L1078">                        throw new ScriptException(&quot;Attempted OP_PICK/OP_ROLL on an empty stack&quot;);</span>
<span class="fc" id="L1079">                    long val = castToBigInteger(stack.pollLast()).longValue();</span>
<span class="fc bfc" id="L1080" title="All 4 branches covered.">                    if (val &lt; 0 || val &gt;= stack.size())</span>
<span class="fc" id="L1081">                        throw new ScriptException(&quot;OP_PICK/OP_ROLL attempted to get data deeper than stack size&quot;);</span>
<span class="fc" id="L1082">                    Iterator&lt;byte[]&gt; itPICK = stack.descendingIterator();</span>
<span class="fc bfc" id="L1083" title="All 2 branches covered.">                    for (long i = 0; i &lt; val; i++)</span>
<span class="fc" id="L1084">                        itPICK.next();</span>
<span class="fc" id="L1085">                    byte[] OPROLLtmpChunk = itPICK.next();</span>
<span class="fc bfc" id="L1086" title="All 2 branches covered.">                    if (opcode == OP_ROLL)</span>
<span class="fc" id="L1087">                        itPICK.remove();</span>
<span class="fc" id="L1088">                    stack.add(OPROLLtmpChunk);</span>
<span class="fc" id="L1089">                    break;</span>
                case OP_ROT:
<span class="fc bfc" id="L1091" title="All 2 branches covered.">                    if (stack.size() &lt; 3)</span>
<span class="fc" id="L1092">                        throw new ScriptException(&quot;Attempted OP_ROT on a stack with size &lt; 3&quot;);</span>
<span class="fc" id="L1093">                    byte[] OPROTtmpChunk3 = stack.pollLast();</span>
<span class="fc" id="L1094">                    byte[] OPROTtmpChunk2 = stack.pollLast();</span>
<span class="fc" id="L1095">                    byte[] OPROTtmpChunk1 = stack.pollLast();</span>
<span class="fc" id="L1096">                    stack.add(OPROTtmpChunk2);</span>
<span class="fc" id="L1097">                    stack.add(OPROTtmpChunk3);</span>
<span class="fc" id="L1098">                    stack.add(OPROTtmpChunk1);</span>
<span class="fc" id="L1099">                    break;</span>
                case OP_SWAP:
                case OP_TUCK:
<span class="fc bfc" id="L1102" title="All 2 branches covered.">                    if (stack.size() &lt; 2)</span>
<span class="fc" id="L1103">                        throw new ScriptException(&quot;Attempted OP_SWAP on a stack with size &lt; 2&quot;);</span>
<span class="fc" id="L1104">                    byte[] OPSWAPtmpChunk2 = stack.pollLast();</span>
<span class="fc" id="L1105">                    byte[] OPSWAPtmpChunk1 = stack.pollLast();</span>
<span class="fc" id="L1106">                    stack.add(OPSWAPtmpChunk2);</span>
<span class="fc" id="L1107">                    stack.add(OPSWAPtmpChunk1);</span>
<span class="fc bfc" id="L1108" title="All 2 branches covered.">                    if (opcode == OP_TUCK)</span>
<span class="fc" id="L1109">                        stack.add(OPSWAPtmpChunk2);</span>
                    break;
                case OP_CAT:
                case OP_SUBSTR:
                case OP_LEFT:
                case OP_RIGHT:
<span class="nc" id="L1115">                    throw new ScriptException(&quot;Attempted to use disabled Script Op.&quot;);</span>
                case OP_SIZE:
<span class="fc bfc" id="L1117" title="All 2 branches covered.">                    if (stack.size() &lt; 1)</span>
<span class="fc" id="L1118">                        throw new ScriptException(&quot;Attempted OP_SIZE on an empty stack&quot;);</span>
<span class="fc" id="L1119">                    stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(stack.getLast().length), false)));</span>
<span class="fc" id="L1120">                    break;</span>
                case OP_INVERT:
                case OP_AND:
                case OP_OR:
                case OP_XOR:
<span class="nc" id="L1125">                    throw new ScriptException(&quot;Attempted to use disabled Script Op.&quot;);</span>
                case OP_EQUAL:
<span class="fc bfc" id="L1127" title="All 2 branches covered.">                    if (stack.size() &lt; 2)</span>
<span class="fc" id="L1128">                        throw new ScriptException(&quot;Attempted OP_EQUAL on a stack with size &lt; 2&quot;);</span>
<span class="fc bfc" id="L1129" title="All 2 branches covered.">                    stack.add(Arrays.equals(stack.pollLast(), stack.pollLast()) ? new byte[] {1} : new byte[] {});</span>
<span class="fc" id="L1130">                    break;</span>
                case OP_EQUALVERIFY:
<span class="fc bfc" id="L1132" title="All 2 branches covered.">                    if (stack.size() &lt; 2)</span>
<span class="fc" id="L1133">                        throw new ScriptException(&quot;Attempted OP_EQUALVERIFY on a stack with size &lt; 2&quot;);</span>
<span class="fc bfc" id="L1134" title="All 2 branches covered.">                    if (!Arrays.equals(stack.pollLast(), stack.pollLast()))</span>
<span class="fc" id="L1135">                        throw new ScriptException(&quot;OP_EQUALVERIFY: non-equal data&quot;);</span>
                    break;
                case OP_1ADD:
                case OP_1SUB:
                case OP_NEGATE:
                case OP_ABS:
                case OP_NOT:
                case OP_0NOTEQUAL:
<span class="fc bfc" id="L1143" title="All 2 branches covered.">                    if (stack.size() &lt; 1)</span>
<span class="fc" id="L1144">                        throw new ScriptException(&quot;Attempted a numeric op on an empty stack&quot;);</span>
<span class="fc" id="L1145">                    BigInteger numericOPnum = castToBigInteger(stack.pollLast());</span>
                                        
<span class="pc bpc" id="L1147" title="1 of 7 branches missed.">                    switch (opcode) {</span>
                    case OP_1ADD:
<span class="fc" id="L1149">                        numericOPnum = numericOPnum.add(BigInteger.ONE);</span>
<span class="fc" id="L1150">                        break;</span>
                    case OP_1SUB:
<span class="fc" id="L1152">                        numericOPnum = numericOPnum.subtract(BigInteger.ONE);</span>
<span class="fc" id="L1153">                        break;</span>
                    case OP_NEGATE:
<span class="fc" id="L1155">                        numericOPnum = numericOPnum.negate();</span>
<span class="fc" id="L1156">                        break;</span>
                    case OP_ABS:
<span class="fc bfc" id="L1158" title="All 2 branches covered.">                        if (numericOPnum.signum() &lt; 0)</span>
<span class="fc" id="L1159">                            numericOPnum = numericOPnum.negate();</span>
                        break;
                    case OP_NOT:
<span class="fc bfc" id="L1162" title="All 2 branches covered.">                        if (numericOPnum.equals(BigInteger.ZERO))</span>
<span class="fc" id="L1163">                            numericOPnum = BigInteger.ONE;</span>
                        else
<span class="fc" id="L1165">                            numericOPnum = BigInteger.ZERO;</span>
<span class="fc" id="L1166">                        break;</span>
                    case OP_0NOTEQUAL:
<span class="fc bfc" id="L1168" title="All 2 branches covered.">                        if (numericOPnum.equals(BigInteger.ZERO))</span>
<span class="fc" id="L1169">                            numericOPnum = BigInteger.ZERO;</span>
                        else
<span class="fc" id="L1171">                            numericOPnum = BigInteger.ONE;</span>
<span class="fc" id="L1172">                        break;</span>
                    default:
<span class="nc" id="L1174">                        throw new AssertionError(&quot;Unreachable&quot;);</span>
                    }
                    
<span class="fc" id="L1177">                    stack.add(Utils.reverseBytes(Utils.encodeMPI(numericOPnum, false)));</span>
<span class="fc" id="L1178">                    break;</span>
                case OP_2MUL:
                case OP_2DIV:
<span class="nc" id="L1181">                    throw new ScriptException(&quot;Attempted to use disabled Script Op.&quot;);</span>
                case OP_ADD:
                case OP_SUB:
                case OP_BOOLAND:
                case OP_BOOLOR:
                case OP_NUMEQUAL:
                case OP_NUMNOTEQUAL:
                case OP_LESSTHAN:
                case OP_GREATERTHAN:
                case OP_LESSTHANOREQUAL:
                case OP_GREATERTHANOREQUAL:
                case OP_MIN:
                case OP_MAX:
<span class="fc bfc" id="L1194" title="All 2 branches covered.">                    if (stack.size() &lt; 2)</span>
<span class="fc" id="L1195">                        throw new ScriptException(&quot;Attempted a numeric op on a stack with size &lt; 2&quot;);</span>
<span class="fc" id="L1196">                    BigInteger numericOPnum2 = castToBigInteger(stack.pollLast());</span>
<span class="fc" id="L1197">                    BigInteger numericOPnum1 = castToBigInteger(stack.pollLast());</span>

                    BigInteger numericOPresult;
<span class="pc bpc" id="L1200" title="1 of 13 branches missed.">                    switch (opcode) {</span>
                    case OP_ADD:
<span class="fc" id="L1202">                        numericOPresult = numericOPnum1.add(numericOPnum2);</span>
<span class="fc" id="L1203">                        break;</span>
                    case OP_SUB:
<span class="fc" id="L1205">                        numericOPresult = numericOPnum1.subtract(numericOPnum2);</span>
<span class="fc" id="L1206">                        break;</span>
                    case OP_BOOLAND:
<span class="fc bfc" id="L1208" title="All 4 branches covered.">                        if (!numericOPnum1.equals(BigInteger.ZERO) &amp;&amp; !numericOPnum2.equals(BigInteger.ZERO))</span>
<span class="fc" id="L1209">                            numericOPresult = BigInteger.ONE;</span>
                        else
<span class="fc" id="L1211">                            numericOPresult = BigInteger.ZERO;</span>
<span class="fc" id="L1212">                        break;</span>
                    case OP_BOOLOR:
<span class="fc bfc" id="L1214" title="All 4 branches covered.">                        if (!numericOPnum1.equals(BigInteger.ZERO) || !numericOPnum2.equals(BigInteger.ZERO))</span>
<span class="fc" id="L1215">                            numericOPresult = BigInteger.ONE;</span>
                        else
<span class="fc" id="L1217">                            numericOPresult = BigInteger.ZERO;</span>
<span class="fc" id="L1218">                        break;</span>
                    case OP_NUMEQUAL:
<span class="pc bpc" id="L1220" title="1 of 2 branches missed.">                        if (numericOPnum1.equals(numericOPnum2))</span>
<span class="fc" id="L1221">                            numericOPresult = BigInteger.ONE;</span>
                        else
<span class="nc" id="L1223">                            numericOPresult = BigInteger.ZERO;</span>
<span class="nc" id="L1224">                        break;</span>
                    case OP_NUMNOTEQUAL:
<span class="fc bfc" id="L1226" title="All 2 branches covered.">                        if (!numericOPnum1.equals(numericOPnum2))</span>
<span class="fc" id="L1227">                            numericOPresult = BigInteger.ONE;</span>
                        else
<span class="fc" id="L1229">                            numericOPresult = BigInteger.ZERO;</span>
<span class="fc" id="L1230">                        break;</span>
                    case OP_LESSTHAN:
<span class="fc bfc" id="L1232" title="All 2 branches covered.">                        if (numericOPnum1.compareTo(numericOPnum2) &lt; 0)</span>
<span class="fc" id="L1233">                            numericOPresult = BigInteger.ONE;</span>
                        else
<span class="fc" id="L1235">                            numericOPresult = BigInteger.ZERO;</span>
<span class="fc" id="L1236">                        break;</span>
                    case OP_GREATERTHAN:
<span class="fc bfc" id="L1238" title="All 2 branches covered.">                        if (numericOPnum1.compareTo(numericOPnum2) &gt; 0)</span>
<span class="fc" id="L1239">                            numericOPresult = BigInteger.ONE;</span>
                        else
<span class="fc" id="L1241">                            numericOPresult = BigInteger.ZERO;</span>
<span class="fc" id="L1242">                        break;</span>
                    case OP_LESSTHANOREQUAL:
<span class="fc bfc" id="L1244" title="All 2 branches covered.">                        if (numericOPnum1.compareTo(numericOPnum2) &lt;= 0)</span>
<span class="fc" id="L1245">                            numericOPresult = BigInteger.ONE;</span>
                        else
<span class="fc" id="L1247">                            numericOPresult = BigInteger.ZERO;</span>
<span class="fc" id="L1248">                        break;</span>
                    case OP_GREATERTHANOREQUAL:
<span class="fc bfc" id="L1250" title="All 2 branches covered.">                        if (numericOPnum1.compareTo(numericOPnum2) &gt;= 0)</span>
<span class="fc" id="L1251">                            numericOPresult = BigInteger.ONE;</span>
                        else
<span class="fc" id="L1253">                            numericOPresult = BigInteger.ZERO;</span>
<span class="fc" id="L1254">                        break;</span>
                    case OP_MIN:
<span class="fc bfc" id="L1256" title="All 2 branches covered.">                        if (numericOPnum1.compareTo(numericOPnum2) &lt; 0)</span>
<span class="fc" id="L1257">                            numericOPresult = numericOPnum1;</span>
                        else
<span class="fc" id="L1259">                            numericOPresult = numericOPnum2;</span>
<span class="fc" id="L1260">                        break;</span>
                    case OP_MAX:
<span class="fc bfc" id="L1262" title="All 2 branches covered.">                        if (numericOPnum1.compareTo(numericOPnum2) &gt; 0)</span>
<span class="fc" id="L1263">                            numericOPresult = numericOPnum1;</span>
                        else
<span class="fc" id="L1265">                            numericOPresult = numericOPnum2;</span>
<span class="fc" id="L1266">                        break;</span>
                    default:
<span class="nc" id="L1268">                        throw new RuntimeException(&quot;Opcode switched at runtime?&quot;);</span>
                    }
                    
<span class="fc" id="L1271">                    stack.add(Utils.reverseBytes(Utils.encodeMPI(numericOPresult, false)));</span>
<span class="fc" id="L1272">                    break;</span>
                case OP_MUL:
                case OP_DIV:
                case OP_MOD:
                case OP_LSHIFT:
                case OP_RSHIFT:
<span class="nc" id="L1278">                    throw new ScriptException(&quot;Attempted to use disabled Script Op.&quot;);</span>
                case OP_NUMEQUALVERIFY:
<span class="fc bfc" id="L1280" title="All 2 branches covered.">                    if (stack.size() &lt; 2)</span>
<span class="fc" id="L1281">                        throw new ScriptException(&quot;Attempted OP_NUMEQUALVERIFY on a stack with size &lt; 2&quot;);</span>
<span class="fc" id="L1282">                    BigInteger OPNUMEQUALVERIFYnum2 = castToBigInteger(stack.pollLast());</span>
<span class="fc" id="L1283">                    BigInteger OPNUMEQUALVERIFYnum1 = castToBigInteger(stack.pollLast());</span>
                    
<span class="pc bpc" id="L1285" title="1 of 2 branches missed.">                    if (!OPNUMEQUALVERIFYnum1.equals(OPNUMEQUALVERIFYnum2))</span>
<span class="nc" id="L1286">                        throw new ScriptException(&quot;OP_NUMEQUALVERIFY failed&quot;);</span>
                    break;
                case OP_WITHIN:
<span class="fc bfc" id="L1289" title="All 2 branches covered.">                    if (stack.size() &lt; 3)</span>
<span class="fc" id="L1290">                        throw new ScriptException(&quot;Attempted OP_WITHIN on a stack with size &lt; 3&quot;);</span>
<span class="fc" id="L1291">                    BigInteger OPWITHINnum3 = castToBigInteger(stack.pollLast());</span>
<span class="fc" id="L1292">                    BigInteger OPWITHINnum2 = castToBigInteger(stack.pollLast());</span>
<span class="fc" id="L1293">                    BigInteger OPWITHINnum1 = castToBigInteger(stack.pollLast());</span>
<span class="fc bfc" id="L1294" title="All 4 branches covered.">                    if (OPWITHINnum2.compareTo(OPWITHINnum1) &lt;= 0 &amp;&amp; OPWITHINnum1.compareTo(OPWITHINnum3) &lt; 0)</span>
<span class="fc" id="L1295">                        stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ONE, false)));</span>
                    else
<span class="fc" id="L1297">                        stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ZERO, false)));</span>
<span class="fc" id="L1298">                    break;</span>
                case OP_RIPEMD160:
<span class="fc bfc" id="L1300" title="All 2 branches covered.">                    if (stack.size() &lt; 1)</span>
<span class="fc" id="L1301">                        throw new ScriptException(&quot;Attempted OP_RIPEMD160 on an empty stack&quot;);</span>
<span class="fc" id="L1302">                    RIPEMD160Digest digest = new RIPEMD160Digest();</span>
<span class="fc" id="L1303">                    byte[] dataToHash = stack.pollLast();</span>
<span class="fc" id="L1304">                    digest.update(dataToHash, 0, dataToHash.length);</span>
<span class="fc" id="L1305">                    byte[] ripmemdHash = new byte[20];</span>
<span class="fc" id="L1306">                    digest.doFinal(ripmemdHash, 0);</span>
<span class="fc" id="L1307">                    stack.add(ripmemdHash);</span>
<span class="fc" id="L1308">                    break;</span>
                case OP_SHA1:
<span class="fc bfc" id="L1310" title="All 2 branches covered.">                    if (stack.size() &lt; 1)</span>
<span class="fc" id="L1311">                        throw new ScriptException(&quot;Attempted OP_SHA1 on an empty stack&quot;);</span>
                    try {
<span class="fc" id="L1313">                        stack.add(MessageDigest.getInstance(&quot;SHA-1&quot;).digest(stack.pollLast()));</span>
<span class="nc" id="L1314">                    } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L1315">                        throw new RuntimeException(e);  // Cannot happen.</span>
<span class="fc" id="L1316">                    }</span>
                    break;
                case OP_SHA256:
<span class="fc bfc" id="L1319" title="All 2 branches covered.">                    if (stack.size() &lt; 1)</span>
<span class="fc" id="L1320">                        throw new ScriptException(&quot;Attempted OP_SHA256 on an empty stack&quot;);</span>
<span class="fc" id="L1321">                    stack.add(Sha256Hash.hash(stack.pollLast()));</span>
<span class="fc" id="L1322">                    break;</span>
                case OP_HASH160:
<span class="fc bfc" id="L1324" title="All 2 branches covered.">                    if (stack.size() &lt; 1)</span>
<span class="fc" id="L1325">                        throw new ScriptException(&quot;Attempted OP_HASH160 on an empty stack&quot;);</span>
<span class="fc" id="L1326">                    stack.add(Utils.sha256hash160(stack.pollLast()));</span>
<span class="fc" id="L1327">                    break;</span>
                case OP_HASH256:
<span class="fc bfc" id="L1329" title="All 2 branches covered.">                    if (stack.size() &lt; 1)</span>
<span class="fc" id="L1330">                        throw new ScriptException(&quot;Attempted OP_SHA256 on an empty stack&quot;);</span>
<span class="fc" id="L1331">                    stack.add(Sha256Hash.hashTwice(stack.pollLast()));</span>
<span class="fc" id="L1332">                    break;</span>
                case OP_CODESEPARATOR:
<span class="fc" id="L1334">                    lastCodeSepLocation = chunk.getStartLocationInProgram() + 1;</span>
<span class="fc" id="L1335">                    break;</span>
                case OP_CHECKSIG:
                case OP_CHECKSIGVERIFY:
<span class="pc bpc" id="L1338" title="1 of 2 branches missed.">                    if (txContainingThis == null)</span>
<span class="nc" id="L1339">                        throw new IllegalStateException(&quot;Script attempted signature check but no tx was provided&quot;);</span>
<span class="fc" id="L1340">                    executeCheckSig(txContainingThis, (int) index, script, stack, lastCodeSepLocation, opcode, verifyFlags);</span>
<span class="fc" id="L1341">                    break;</span>
                case OP_CHECKMULTISIG:
                case OP_CHECKMULTISIGVERIFY:
<span class="pc bpc" id="L1344" title="1 of 2 branches missed.">                    if (txContainingThis == null)</span>
<span class="nc" id="L1345">                        throw new IllegalStateException(&quot;Script attempted signature check but no tx was provided&quot;);</span>
<span class="fc" id="L1346">                    opCount = executeMultiSig(txContainingThis, (int) index, script, stack, opCount, lastCodeSepLocation, opcode, verifyFlags);</span>
<span class="fc" id="L1347">                    break;</span>
                case OP_CHECKLOCKTIMEVERIFY:
<span class="fc bfc" id="L1349" title="All 2 branches covered.">                    if (!verifyFlags.contains(VerifyFlag.CHECKLOCKTIMEVERIFY)) {</span>
                        // not enabled; treat as a NOP2
<span class="pc bpc" id="L1351" title="1 of 2 branches missed.">                        if (verifyFlags.contains(VerifyFlag.DISCOURAGE_UPGRADABLE_NOPS)) {</span>
<span class="nc" id="L1352">                            throw new ScriptException(&quot;Script used a reserved opcode &quot; + opcode);</span>
                        }
                        break;
                    }
<span class="fc" id="L1356">                    executeCheckLockTimeVerify(txContainingThis, (int) index, script, stack, lastCodeSepLocation, opcode, verifyFlags);</span>
<span class="fc" id="L1357">                    break;</span>
                case OP_NOP1:
                case OP_NOP3:
                case OP_NOP4:
                case OP_NOP5:
                case OP_NOP6:
                case OP_NOP7:
                case OP_NOP8:
                case OP_NOP9:
                case OP_NOP10:
<span class="pc bpc" id="L1367" title="1 of 2 branches missed.">                    if (verifyFlags.contains(VerifyFlag.DISCOURAGE_UPGRADABLE_NOPS)) {</span>
<span class="nc" id="L1368">                        throw new ScriptException(&quot;Script used a reserved opcode &quot; + opcode);</span>
                    }
                    break;
                    
                default:
<span class="fc" id="L1373">                    throw new ScriptException(&quot;Script used a reserved opcode &quot; + opcode);</span>
                }
            }
            
<span class="pc bpc" id="L1377" title="1 of 4 branches missed.">            if (stack.size() + altstack.size() &gt; 1000 || stack.size() + altstack.size() &lt; 0)</span>
<span class="fc" id="L1378">                throw new ScriptException(&quot;Stack size exceeded range&quot;);</span>
<span class="fc" id="L1379">        }</span>
        
<span class="fc bfc" id="L1381" title="All 2 branches covered.">        if (!ifStack.isEmpty())</span>
<span class="fc" id="L1382">            throw new ScriptException(&quot;OP_IF/OP_NOTIF without OP_ENDIF&quot;);</span>
<span class="fc" id="L1383">    }</span>

    // This is more or less a direct translation of the code in FLO Core
    private static void executeCheckLockTimeVerify(Transaction txContainingThis, int index, Script script, LinkedList&lt;byte[]&gt; stack,
                                        int lastCodeSepLocation, int opcode,
                                        Set&lt;VerifyFlag&gt; verifyFlags) throws ScriptException {
<span class="fc bfc" id="L1389" title="All 2 branches covered.">        if (stack.size() &lt; 1)</span>
<span class="fc" id="L1390">            throw new ScriptException(&quot;Attempted OP_CHECKLOCKTIMEVERIFY on a stack with size &lt; 1&quot;);</span>

        // Thus as a special case we tell CScriptNum to accept up
        // to 5-byte bignums to avoid year 2038 issue.
<span class="fc" id="L1394">        final BigInteger nLockTime = castToBigInteger(stack.getLast(), 5);</span>

<span class="fc bfc" id="L1396" title="All 2 branches covered.">        if (nLockTime.compareTo(BigInteger.ZERO) &lt; 0)</span>
<span class="fc" id="L1397">            throw new ScriptException(&quot;Negative locktime&quot;);</span>

        // There are two kinds of nLockTime, need to ensure we're comparing apples-to-apples
<span class="fc" id="L1400">        if (!(</span>
<span class="fc bfc" id="L1401" title="All 4 branches covered.">            ((txContainingThis.getLockTime() &lt;  Transaction.LOCKTIME_THRESHOLD) &amp;&amp; (nLockTime.compareTo(Transaction.LOCKTIME_THRESHOLD_BIG)) &lt; 0) ||</span>
<span class="fc bfc" id="L1402" title="All 4 branches covered.">            ((txContainingThis.getLockTime() &gt;= Transaction.LOCKTIME_THRESHOLD) &amp;&amp; (nLockTime.compareTo(Transaction.LOCKTIME_THRESHOLD_BIG)) &gt;= 0))</span>
        )
<span class="fc" id="L1404">            throw new ScriptException(&quot;Locktime requirement type mismatch&quot;);</span>

        // Now that we know we're comparing apples-to-apples, the
        // comparison is a simple numeric one.
<span class="fc bfc" id="L1408" title="All 2 branches covered.">        if (nLockTime.compareTo(BigInteger.valueOf(txContainingThis.getLockTime())) &gt; 0)</span>
<span class="fc" id="L1409">            throw new ScriptException(&quot;Locktime requirement not satisfied&quot;);</span>

        // Finally the nLockTime feature can be disabled and thus
        // CHECKLOCKTIMEVERIFY bypassed if every txin has been
        // finalized by setting nSequence to maxint. The
        // transaction would be allowed into the blockchain, making
        // the opcode ineffective.
        //
        // Testing if this vin is not final is sufficient to
        // prevent this condition. Alternatively we could test all
        // inputs, but testing just this input minimizes the data
        // required to prove correct CHECKLOCKTIMEVERIFY execution.
<span class="fc bfc" id="L1421" title="All 2 branches covered.">        if (!txContainingThis.getInput(index).hasSequence())</span>
<span class="fc" id="L1422">            throw new ScriptException(&quot;Transaction contains a final transaction input for a CHECKLOCKTIMEVERIFY script.&quot;);</span>
<span class="fc" id="L1423">    }</span>

    private static void executeCheckSig(Transaction txContainingThis, int index, Script script, LinkedList&lt;byte[]&gt; stack,
                                        int lastCodeSepLocation, int opcode, 
                                        Set&lt;VerifyFlag&gt; verifyFlags) throws ScriptException {
<span class="fc bfc" id="L1428" title="All 2 branches covered.">        final boolean requireCanonical = verifyFlags.contains(VerifyFlag.STRICTENC)</span>
<span class="fc bfc" id="L1429" title="All 2 branches covered.">            || verifyFlags.contains(VerifyFlag.DERSIG)</span>
<span class="fc bfc" id="L1430" title="All 2 branches covered.">            || verifyFlags.contains(VerifyFlag.LOW_S);</span>
<span class="fc bfc" id="L1431" title="All 2 branches covered.">        if (stack.size() &lt; 2)</span>
<span class="fc" id="L1432">            throw new ScriptException(&quot;Attempted OP_CHECKSIG(VERIFY) on a stack with size &lt; 2&quot;);</span>
<span class="fc" id="L1433">        byte[] pubKey = stack.pollLast();</span>
<span class="fc" id="L1434">        byte[] sigBytes = stack.pollLast();</span>

<span class="fc" id="L1436">        byte[] prog = script.getProgram();</span>
<span class="fc" id="L1437">        byte[] connectedScript = Arrays.copyOfRange(prog, lastCodeSepLocation, prog.length);</span>

<span class="fc" id="L1439">        UnsafeByteArrayOutputStream outStream = new UnsafeByteArrayOutputStream(sigBytes.length + 1);</span>
        try {
<span class="fc" id="L1441">            writeBytes(outStream, sigBytes);</span>
<span class="nc" id="L1442">        } catch (IOException e) {</span>
<span class="nc" id="L1443">            throw new RuntimeException(e); // Cannot happen</span>
<span class="fc" id="L1444">        }</span>
<span class="fc" id="L1445">        connectedScript = removeAllInstancesOf(connectedScript, outStream.toByteArray());</span>

        // TODO: Use int for indexes everywhere, we can't have that many inputs/outputs
<span class="fc" id="L1448">        boolean sigValid = false;</span>
        try {
<span class="fc" id="L1450">            TransactionSignature sig  = TransactionSignature.decodeFromFLO(sigBytes, requireCanonical,</span>
<span class="fc" id="L1451">                verifyFlags.contains(VerifyFlag.LOW_S));</span>

            // TODO: Should check hash type is known
<span class="fc" id="L1454">            Sha256Hash hash = txContainingThis.hashForSignature(index, connectedScript, (byte) sig.sighashFlags);</span>
<span class="fc" id="L1455">            sigValid = ECKey.verify(hash.getBytes(), sig, pubKey);</span>
<span class="fc" id="L1456">        } catch (Exception e1) {</span>
            // There is (at least) one exception that could be hit here (EOFException, if the sig is too short)
            // Because I can't verify there aren't more, we use a very generic Exception catch

            // This RuntimeException occurs when signing as we run partial/invalid scripts to see if they need more
            // signing work to be done inside LocalTransactionSigner.signInputs.
<span class="fc bfc" id="L1462" title="All 2 branches covered.">            if (!e1.getMessage().contains(&quot;Reached past end of ASN.1 stream&quot;))</span>
<span class="fc" id="L1463">                log.warn(&quot;Signature checking failed!&quot;, e1);</span>
<span class="fc" id="L1464">        }</span>

<span class="fc bfc" id="L1466" title="All 2 branches covered.">        if (opcode == OP_CHECKSIG)</span>
<span class="fc bfc" id="L1467" title="All 2 branches covered.">            stack.add(sigValid ? new byte[] {1} : new byte[] {});</span>
<span class="pc bpc" id="L1468" title="1 of 2 branches missed.">        else if (opcode == OP_CHECKSIGVERIFY)</span>
<span class="fc bfc" id="L1469" title="All 2 branches covered.">            if (!sigValid)</span>
<span class="fc" id="L1470">                throw new ScriptException(&quot;Script failed OP_CHECKSIGVERIFY&quot;);</span>
<span class="fc" id="L1471">    }</span>

    private static int executeMultiSig(Transaction txContainingThis, int index, Script script, LinkedList&lt;byte[]&gt; stack,
                                       int opCount, int lastCodeSepLocation, int opcode, 
                                       Set&lt;VerifyFlag&gt; verifyFlags) throws ScriptException {
<span class="fc bfc" id="L1476" title="All 2 branches covered.">        final boolean requireCanonical = verifyFlags.contains(VerifyFlag.STRICTENC)</span>
<span class="pc bpc" id="L1477" title="1 of 2 branches missed.">            || verifyFlags.contains(VerifyFlag.DERSIG)</span>
<span class="pc bpc" id="L1478" title="1 of 2 branches missed.">            || verifyFlags.contains(VerifyFlag.LOW_S);</span>
<span class="pc bpc" id="L1479" title="1 of 2 branches missed.">        if (stack.size() &lt; 2)</span>
<span class="nc" id="L1480">            throw new ScriptException(&quot;Attempted OP_CHECKMULTISIG(VERIFY) on a stack with size &lt; 2&quot;);</span>
<span class="fc" id="L1481">        int pubKeyCount = castToBigInteger(stack.pollLast()).intValue();</span>
<span class="pc bpc" id="L1482" title="1 of 4 branches missed.">        if (pubKeyCount &lt; 0 || pubKeyCount &gt; 20)</span>
<span class="fc" id="L1483">            throw new ScriptException(&quot;OP_CHECKMULTISIG(VERIFY) with pubkey count out of range&quot;);</span>
<span class="fc" id="L1484">        opCount += pubKeyCount;</span>
<span class="fc bfc" id="L1485" title="All 2 branches covered.">        if (opCount &gt; 201)</span>
<span class="fc" id="L1486">            throw new ScriptException(&quot;Total op count &gt; 201 during OP_CHECKMULTISIG(VERIFY)&quot;);</span>
<span class="pc bpc" id="L1487" title="1 of 2 branches missed.">        if (stack.size() &lt; pubKeyCount + 1)</span>
<span class="nc" id="L1488">            throw new ScriptException(&quot;Attempted OP_CHECKMULTISIG(VERIFY) on a stack with size &lt; num_of_pubkeys + 2&quot;);</span>

<span class="fc" id="L1490">        LinkedList&lt;byte[]&gt; pubkeys = new LinkedList&lt;byte[]&gt;();</span>
<span class="fc bfc" id="L1491" title="All 2 branches covered.">        for (int i = 0; i &lt; pubKeyCount; i++) {</span>
<span class="fc" id="L1492">            byte[] pubKey = stack.pollLast();</span>
<span class="fc" id="L1493">            pubkeys.add(pubKey);</span>
        }

<span class="fc" id="L1496">        int sigCount = castToBigInteger(stack.pollLast()).intValue();</span>
<span class="pc bpc" id="L1497" title="1 of 4 branches missed.">        if (sigCount &lt; 0 || sigCount &gt; pubKeyCount)</span>
<span class="fc" id="L1498">            throw new ScriptException(&quot;OP_CHECKMULTISIG(VERIFY) with sig count out of range&quot;);</span>
<span class="fc bfc" id="L1499" title="All 2 branches covered.">        if (stack.size() &lt; sigCount + 1)</span>
<span class="fc" id="L1500">            throw new ScriptException(&quot;Attempted OP_CHECKMULTISIG(VERIFY) on a stack with size &lt; num_of_pubkeys + num_of_signatures + 3&quot;);</span>

<span class="fc" id="L1502">        LinkedList&lt;byte[]&gt; sigs = new LinkedList&lt;byte[]&gt;();</span>
<span class="fc bfc" id="L1503" title="All 2 branches covered.">        for (int i = 0; i &lt; sigCount; i++) {</span>
<span class="fc" id="L1504">            byte[] sig = stack.pollLast();</span>
<span class="fc" id="L1505">            sigs.add(sig);</span>
        }

<span class="fc" id="L1508">        byte[] prog = script.getProgram();</span>
<span class="fc" id="L1509">        byte[] connectedScript = Arrays.copyOfRange(prog, lastCodeSepLocation, prog.length);</span>

<span class="fc bfc" id="L1511" title="All 2 branches covered.">        for (byte[] sig : sigs) {</span>
<span class="fc" id="L1512">            UnsafeByteArrayOutputStream outStream = new UnsafeByteArrayOutputStream(sig.length + 1);</span>
            try {
<span class="fc" id="L1514">                writeBytes(outStream, sig);</span>
<span class="nc" id="L1515">            } catch (IOException e) {</span>
<span class="nc" id="L1516">                throw new RuntimeException(e); // Cannot happen</span>
<span class="fc" id="L1517">            }</span>
<span class="fc" id="L1518">            connectedScript = removeAllInstancesOf(connectedScript, outStream.toByteArray());</span>
<span class="fc" id="L1519">        }</span>

<span class="fc" id="L1521">        boolean valid = true;</span>
<span class="fc bfc" id="L1522" title="All 2 branches covered.">        while (sigs.size() &gt; 0) {</span>
<span class="fc" id="L1523">            byte[] pubKey = pubkeys.pollFirst();</span>
            // We could reasonably move this out of the loop, but because signature verification is significantly
            // more expensive than hashing, its not a big deal.
            try {
<span class="fc" id="L1527">                TransactionSignature sig = TransactionSignature.decodeFromFLO(sigs.getFirst(), requireCanonical);</span>
<span class="fc" id="L1528">                Sha256Hash hash = txContainingThis.hashForSignature(index, connectedScript, (byte) sig.sighashFlags);</span>
<span class="fc bfc" id="L1529" title="All 2 branches covered.">                if (ECKey.verify(hash.getBytes(), sig, pubKey))</span>
<span class="fc" id="L1530">                    sigs.pollFirst();</span>
<span class="fc" id="L1531">            } catch (Exception e) {</span>
                // There is (at least) one exception that could be hit here (EOFException, if the sig is too short)
                // Because I can't verify there aren't more, we use a very generic Exception catch
<span class="fc" id="L1534">            }</span>

<span class="fc bfc" id="L1536" title="All 2 branches covered.">            if (sigs.size() &gt; pubkeys.size()) {</span>
<span class="fc" id="L1537">                valid = false;</span>
<span class="fc" id="L1538">                break;</span>
            }
<span class="fc" id="L1540">        }</span>

        // We uselessly remove a stack object to emulate a FLO Core bug.
<span class="fc" id="L1543">        byte[] nullDummy = stack.pollLast();</span>
<span class="fc bfc" id="L1544" title="All 4 branches covered.">        if (verifyFlags.contains(VerifyFlag.NULLDUMMY) &amp;&amp; nullDummy.length &gt; 0)</span>
<span class="fc" id="L1545">            throw new ScriptException(&quot;OP_CHECKMULTISIG(VERIFY) with non-null nulldummy: &quot; + Arrays.toString(nullDummy));</span>

<span class="fc bfc" id="L1547" title="All 2 branches covered.">        if (opcode == OP_CHECKMULTISIG) {</span>
<span class="fc bfc" id="L1548" title="All 2 branches covered.">            stack.add(valid ? new byte[] {1} : new byte[] {});</span>
<span class="pc bpc" id="L1549" title="1 of 2 branches missed.">        } else if (opcode == OP_CHECKMULTISIGVERIFY) {</span>
<span class="pc bpc" id="L1550" title="1 of 2 branches missed.">            if (!valid)</span>
<span class="nc" id="L1551">                throw new ScriptException(&quot;Script failed OP_CHECKMULTISIGVERIFY&quot;);</span>
        }
<span class="fc" id="L1553">        return opCount;</span>
    }

    /**
     * Verifies that this script (interpreted as a scriptSig) correctly spends the given scriptPubKey, enabling all
     * validation rules.
     * @param txContainingThis The transaction in which this input scriptSig resides.
     *                         Accessing txContainingThis from another thread while this method runs results in undefined behavior.
     * @param scriptSigIndex The index in txContainingThis of the scriptSig (note: NOT the index of the scriptPubKey).
     * @param scriptPubKey The connected scriptPubKey containing the conditions needed to claim the value.
     * @deprecated Use {@link #correctlySpends(org.bitcoinj.core.Transaction, long, org.bitcoinj.script.Script, java.util.Set)}
     * instead so that verification flags do not change as new verification options
     * are added.
     */
    @Deprecated
    public void correctlySpends(Transaction txContainingThis, long scriptSigIndex, Script scriptPubKey)
            throws ScriptException {
<span class="fc" id="L1570">        correctlySpends(txContainingThis, scriptSigIndex, scriptPubKey, ALL_VERIFY_FLAGS);</span>
<span class="fc" id="L1571">    }</span>

    /**
     * Verifies that this script (interpreted as a scriptSig) correctly spends the given scriptPubKey.
     * @param txContainingThis The transaction in which this input scriptSig resides.
     *                         Accessing txContainingThis from another thread while this method runs results in undefined behavior.
     * @param scriptSigIndex The index in txContainingThis of the scriptSig (note: NOT the index of the scriptPubKey).
     * @param scriptPubKey The connected scriptPubKey containing the conditions needed to claim the value.
     * @param verifyFlags Each flag enables one validation rule. If in doubt, use {@link #correctlySpends(Transaction, long, Script)}
     *                    which sets all flags.
     */
    public void correctlySpends(Transaction txContainingThis, long scriptSigIndex, Script scriptPubKey,
                                Set&lt;VerifyFlag&gt; verifyFlags) throws ScriptException {
        // Clone the transaction because executing the script involves editing it, and if we die, we'll leave
        // the tx half broken (also it's not so thread safe to work on it directly.
        try {
<span class="fc" id="L1587">            txContainingThis = txContainingThis.getParams().getDefaultSerializer().makeTransaction(txContainingThis.bitcoinSerialize());</span>
<span class="nc" id="L1588">        } catch (ProtocolException e) {</span>
<span class="nc" id="L1589">            throw new RuntimeException(e);   // Should not happen unless we were given a totally broken transaction.</span>
<span class="fc" id="L1590">        }</span>
<span class="pc bpc" id="L1591" title="1 of 4 branches missed.">        if (getProgram().length &gt; 10000 || scriptPubKey.getProgram().length &gt; 10000)</span>
<span class="fc" id="L1592">            throw new ScriptException(&quot;Script larger than 10,000 bytes&quot;);</span>
        
<span class="fc" id="L1594">        LinkedList&lt;byte[]&gt; stack = new LinkedList&lt;byte[]&gt;();</span>
<span class="fc" id="L1595">        LinkedList&lt;byte[]&gt; p2shStack = null;</span>
        
<span class="fc" id="L1597">        executeScript(txContainingThis, scriptSigIndex, this, stack, verifyFlags);</span>
<span class="fc bfc" id="L1598" title="All 2 branches covered.">        if (verifyFlags.contains(VerifyFlag.P2SH))</span>
<span class="fc" id="L1599">            p2shStack = new LinkedList&lt;byte[]&gt;(stack);</span>
<span class="fc" id="L1600">        executeScript(txContainingThis, scriptSigIndex, scriptPubKey, stack, verifyFlags);</span>
        
<span class="fc bfc" id="L1602" title="All 2 branches covered.">        if (stack.size() == 0)</span>
<span class="fc" id="L1603">            throw new ScriptException(&quot;Stack empty at end of script execution.&quot;);</span>
        
<span class="fc bfc" id="L1605" title="All 2 branches covered.">        if (!castToBool(stack.pollLast()))</span>
<span class="fc" id="L1606">            throw new ScriptException(&quot;Script resulted in a non-true stack: &quot; + stack);</span>

        // P2SH is pay to script hash. It means that the scriptPubKey has a special form which is a valid
        // program but it has &quot;useless&quot; form that if evaluated as a normal program always returns true.
        // Instead, miners recognize it as special based on its template - it provides a hash of the real scriptPubKey
        // and that must be provided by the input. The goal of this bizarre arrangement is twofold:
        //
        // (1) You can sum up a large, complex script (like a CHECKMULTISIG script) with an address that's the same
        //     size as a regular address. This means it doesn't overload scannable QR codes/NFC tags or become
        //     un-wieldy to copy/paste.
        // (2) It allows the working set to be smaller: nodes perform best when they can store as many unspent outputs
        //     in RAM as possible, so if the outputs are made smaller and the inputs get bigger, then it's better for
        //     overall scalability and performance.

        // TODO: Check if we can take out enforceP2SH if there's a checkpoint at the enforcement block.
<span class="fc bfc" id="L1621" title="All 4 branches covered.">        if (verifyFlags.contains(VerifyFlag.P2SH) &amp;&amp; scriptPubKey.isPayToScriptHash()) {</span>
<span class="fc bfc" id="L1622" title="All 2 branches covered.">            for (ScriptChunk chunk : chunks)</span>
<span class="fc bfc" id="L1623" title="All 4 branches covered.">                if (chunk.isOpCode() &amp;&amp; chunk.opcode &gt; OP_16)</span>
<span class="fc" id="L1624">                    throw new ScriptException(&quot;Attempted to spend a P2SH scriptPubKey with a script that contained script ops&quot;);</span>
            
<span class="fc" id="L1626">            byte[] scriptPubKeyBytes = p2shStack.pollLast();</span>
<span class="fc" id="L1627">            Script scriptPubKeyP2SH = new Script(scriptPubKeyBytes);</span>
            
<span class="fc" id="L1629">            executeScript(txContainingThis, scriptSigIndex, scriptPubKeyP2SH, p2shStack, verifyFlags);</span>
            
<span class="pc bpc" id="L1631" title="1 of 2 branches missed.">            if (p2shStack.size() == 0)</span>
<span class="nc" id="L1632">                throw new ScriptException(&quot;P2SH stack empty at end of script execution.&quot;);</span>
            
<span class="fc bfc" id="L1634" title="All 2 branches covered.">            if (!castToBool(p2shStack.pollLast()))</span>
<span class="fc" id="L1635">                throw new ScriptException(&quot;P2SH script execution resulted in a non-true stack&quot;);</span>
        }
<span class="fc" id="L1637">    }</span>

    // Utility that doesn't copy for internal use
    private byte[] getQuickProgram() {
<span class="fc bfc" id="L1641" title="All 2 branches covered.">        if (program != null)</span>
<span class="fc" id="L1642">            return program;</span>
<span class="fc" id="L1643">        return getProgram();</span>
    }

    /**
     * Get the {@link org.bitcoinj.script.Script.ScriptType}.
     * @return The script type.
     */
    public ScriptType getScriptType() {
<span class="fc" id="L1651">        ScriptType type = ScriptType.NO_TYPE;</span>
<span class="pc bpc" id="L1652" title="1 of 2 branches missed.">        if (isSentToAddress()) {</span>
<span class="nc" id="L1653">            type = ScriptType.P2PKH;</span>
<span class="fc bfc" id="L1654" title="All 2 branches covered.">        } else if (isSentToRawPubKey()) {</span>
<span class="fc" id="L1655">            type = ScriptType.PUB_KEY;</span>
<span class="fc bfc" id="L1656" title="All 2 branches covered.">        } else if (isPayToScriptHash()) {</span>
<span class="fc" id="L1657">            type = ScriptType.P2SH;</span>
        }
<span class="fc" id="L1659">        return type;</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="pc bpc" id="L1664" title="1 of 2 branches missed.">        if (this == o) return true;</span>
<span class="pc bpc" id="L1665" title="2 of 4 branches missed.">        if (o == null || getClass() != o.getClass()) return false;</span>
<span class="fc" id="L1666">        return Arrays.equals(getQuickProgram(), ((Script)o).getQuickProgram());</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L1671">        return Arrays.hashCode(getQuickProgram());</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>